/**
 * @file Base Generator Interface
 * @description Interface and types for output generators
 *
 * Generators are responsible for transforming resolved content (rules, personas,
 * commands, hooks) into target-specific output formats. Each generator handles
 * a specific target platform (Cursor, Claude, Factory).
 */

import { filterServersByTarget } from '../parsers/mcp.js';

import type { ClaudeSettingsConfig } from '../config/types.js';
import type { LoadResult } from '../loaders/base.js';
import type { ParsedCommand } from '../parsers/command.js';
import type { ParsedHook } from '../parsers/hook.js';
import type { McpConfig } from '../parsers/mcp.js';
import type { ParsedPersona } from '../parsers/persona.js';
import type { ParsedRule } from '../parsers/rule.js';
import type { TargetType } from '../parsers/types.js';

/**
 * Resolved content ready for generation
 */
export interface ResolvedContent extends LoadResult {
  /**
   * Project root directory
   */
  projectRoot: string;

  /**
   * Project name
   */
  projectName?: string;

  /**
   * MCP (Model Context Protocol) configuration
   */
  mcpConfig?: McpConfig;

  /**
   * Claude Code platform-specific settings
   */
  claudeSettings?: ClaudeSettingsConfig;
}

/**
 * Options for generating output
 */
export interface GeneratorOptions {
  /**
   * Output directory (defaults to project root)
   */
  outputDir?: string | undefined;

  /**
   * Clean existing files before generating
   */
  clean?: boolean | undefined;

  /**
   * Add "do not edit" headers to generated files
   */
  addHeaders?: boolean | undefined;

  /**
   * Dry run mode - don't write files
   */
  dryRun?: boolean | undefined;

  /**
   * Verbose output
   */
  verbose?: boolean | undefined;
}

/**
 * Generated file entry
 */
export interface GeneratedFile {
  /**
   * Relative path from output directory
   */
  path: string;

  /**
   * File content
   */
  content: string;

  /**
   * Content type for this file
   */
  type: 'rule' | 'persona' | 'command' | 'hook' | 'config' | 'entrypoint';
}

/**
 * Result of a generation operation
 */
export interface GenerateResult {
  /**
   * Files that were created or updated
   */
  files: string[];

  /**
   * Files that were deleted (if clean mode)
   */
  deleted: string[];

  /**
   * Warnings encountered during generation
   */
  warnings: string[];

  /**
   * Generated files with content (for dry-run or inspection)
   */
  generated?: GeneratedFile[];
}

/**
 * Interface that all generators must implement
 */
export interface Generator {
  /**
   * Unique name for this generator (e.g., 'cursor', 'claude', 'factory', 'subfolder')
   */
  readonly name: TargetType | 'subfolder';

  /**
   * Generate output files
   */
  generate(content: ResolvedContent, options?: GeneratorOptions): Promise<GenerateResult>;
}

/**
 * Create an empty generate result
 */
export function emptyGenerateResult(): GenerateResult {
  return {
    files: [],
    deleted: [],
    warnings: [],
  };
}

/**
 * Merge multiple generate results
 */
export function mergeGenerateResults(...results: GenerateResult[]): GenerateResult {
  const merged: GenerateResult = {
    files: results.flatMap((r) => r.files),
    deleted: results.flatMap((r) => r.deleted),
    warnings: results.flatMap((r) => r.warnings),
  };

  // Merge generated arrays if any exist
  const allGenerated = results.flatMap((r) => r.generated ?? []);
  if (allGenerated.length > 0) {
    merged.generated = allGenerated;
  }

  return merged;
}

/**
 * Get statistics for a generate result
 */
export function getGenerateResultStats(result: GenerateResult): {
  files: number;
  deleted: number;
  warnings: number;
} {
  return {
    files: result.files.length,
    deleted: result.deleted.length,
    warnings: result.warnings.length,
  };
}

/**
 * Header text for generated files
 */
export const DO_NOT_EDIT_HEADER = `<!-- 
  DO NOT EDIT THIS FILE DIRECTLY
  Generated by ai-tool-sync. Edit the source files in .ai/ instead.
-->

`;

/**
 * Header for YAML/JSON files
 */
export const DO_NOT_EDIT_HEADER_YAML = `# DO NOT EDIT THIS FILE DIRECTLY
# Generated by ai-tool-sync. Edit the source files in .ai/ instead.

`;

/**
 * Header for JSON files (as comment can't be used) - add this key to JSON objects
 */
export const DO_NOT_EDIT_COMMENT_JSON = {
  __generated_by: 'ai-tool-sync - DO NOT EDIT DIRECTLY',
};

/**
 * Filter content by target
 */
export function filterContentByTarget(
  content: ResolvedContent,
  target: TargetType
): ResolvedContent {
  const filtered: ResolvedContent = {
    ...content,
    rules: content.rules.filter((r) =>
      (r.frontmatter.targets ?? ['cursor', 'claude', 'factory']).includes(target)
    ),
    personas: content.personas.filter((p) =>
      (p.frontmatter.targets ?? ['cursor', 'claude', 'factory']).includes(target)
    ),
    commands: content.commands.filter((c) =>
      (c.frontmatter.targets ?? ['cursor', 'claude', 'factory']).includes(target)
    ),
    hooks: content.hooks.filter((h) =>
      (h.frontmatter.targets ?? ['claude']).includes(target)
    ),
  };

  // Filter MCP config if present
  if (content.mcpConfig) {
    filtered.mcpConfig = filterServersByTarget(content.mcpConfig, target);
  }

  return filtered;
}

/**
 * Sort rules by priority for consistent ordering
 */
export function sortRulesByPriority(rules: ParsedRule[]): ParsedRule[] {
  const priorityOrder: Record<string, number> = {
    high: 0,
    medium: 1,
    low: 2,
  };

  return [...rules].sort((a, b) => {
    const aPriority = a.frontmatter.priority ?? 'medium';
    const bPriority = b.frontmatter.priority ?? 'medium';
    return (priorityOrder[aPriority] ?? 1) - (priorityOrder[bPriority] ?? 1);
  });
}

/**
 * Sort personas alphabetically by name
 */
export function sortPersonasByName(personas: ParsedPersona[]): ParsedPersona[] {
  return [...personas].sort((a, b) =>
    a.frontmatter.name.localeCompare(b.frontmatter.name)
  );
}

/**
 * Sort commands alphabetically by name
 */
export function sortCommandsByName(commands: ParsedCommand[]): ParsedCommand[] {
  return [...commands].sort((a, b) =>
    a.frontmatter.name.localeCompare(b.frontmatter.name)
  );
}

/**
 * Sort hooks by event then by name
 */
export function sortHooksByEvent(hooks: ParsedHook[]): ParsedHook[] {
  const eventOrder: Record<string, number> = {
    PreToolUse: 0,
    PostToolUse: 1,
    PreMessage: 2,
    PostMessage: 3,
    PreCommit: 4,
  };

  return [...hooks].sort((a, b) => {
    const aEvent = eventOrder[a.frontmatter.event] ?? 99;
    const bEvent = eventOrder[b.frontmatter.event] ?? 99;
    if (aEvent !== bEvent) return aEvent - bEvent;
    return a.frontmatter.name.localeCompare(b.frontmatter.name);
  });
}

/**
 * Generate a safe filename from a name
 * Converts spaces and special chars to hyphens, lowercases
 */
export function toSafeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/**
 * Generate a slug from a name (similar to toSafeFilename but preserves slashes for paths)
 */
export function toSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9/-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-+/g, '-');
}

/**
 * Create resolved content from load result
 */
export function createResolvedContent(
  loadResult: LoadResult,
  projectRoot: string,
  projectName?: string,
  mcpConfig?: McpConfig,
  claudeSettings?: ClaudeSettingsConfig
): ResolvedContent {
  const resolved: ResolvedContent = {
    ...loadResult,
    projectRoot,
  };

  if (projectName !== undefined) {
    resolved.projectName = projectName;
  }

  if (mcpConfig !== undefined) {
    resolved.mcpConfig = mcpConfig;
  }

  if (claudeSettings !== undefined) {
    resolved.claudeSettings = claudeSettings;
  }

  return resolved;
}

/**
 * Check if resolved content has any items
 */
export function hasContent(content: ResolvedContent): boolean {
  return (
    content.rules.length > 0 ||
    content.personas.length > 0 ||
    content.commands.length > 0 ||
    content.hooks.length > 0
  );
}

/**
 * Get content statistics
 */
export function getContentStats(content: ResolvedContent): {
  rules: number;
  personas: number;
  commands: number;
  hooks: number;
  total: number;
} {
  return {
    rules: content.rules.length,
    personas: content.personas.length,
    commands: content.commands.length,
    hooks: content.hooks.length,
    total:
      content.rules.length +
      content.personas.length +
      content.commands.length +
      content.hooks.length,
  };
}
