/**
 * @file Manifest Utilities
 * @description Generate and manage .ai-tool-sync-generated manifest file
 *
 * The manifest tracks all files generated by ai-tool-sync, enabling:
 * - Clean up of previously generated files
 * - .gitignore management
 * - Detection of manual edits to generated files
 */

import * as path from 'node:path';

import { fileExists, readFile, writeFile } from './fs.js';
import { ok, err, type Result } from './result.js';

/**
 * Name of the manifest file
 */
export const MANIFEST_FILENAME = '.ai-tool-sync-generated';

/**
 * Manifest file content structure
 */
export interface Manifest {
  /**
   * Version of ai-tool-sync that generated this manifest
   */
  version: string;

  /**
   * Timestamp when the manifest was last updated
   */
  timestamp: string;

  /**
   * List of generated file paths (relative to project root)
   */
  files: string[];

  /**
   * List of generated directories (relative to project root)
   */
  directories: string[];
}

/**
 * Default directories that are always generated
 */
export const DEFAULT_GENERATED_DIRECTORIES: readonly string[] = [
  '.cursor/rules/',
  '.cursor/commands/',
  '.claude/',
  '.factory/',
] as const;

/**
 * Default files that may be generated at project root
 */
export const DEFAULT_GENERATED_FILES: readonly string[] = [
  'CLAUDE.md',
  'AGENTS.md',
  'mcp.json',
] as const;

/**
 * Parse a manifest file content
 */
export function parseManifest(content: string): Manifest {
  const lines = content.split('\n');
  let version = '';
  let timestamp = '';
  const files: string[] = [];
  const directories: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      // Extract metadata from special comments
      if (trimmed.startsWith('# version:')) {
        version = trimmed.replace('# version:', '').trim();
      } else if (trimmed.startsWith('# timestamp:')) {
        timestamp = trimmed.replace('# timestamp:', '').trim();
      }
      continue;
    }

    // Directories end with /
    if (trimmed.endsWith('/')) {
      directories.push(trimmed);
    } else {
      files.push(trimmed);
    }
  }

  return { version, timestamp, files, directories };
}

/**
 * Format a manifest to file content
 */
export function formatManifest(manifest: Manifest): string {
  const lines: string[] = [
    '# AI Tool Sync Generated Files',
    '# This file is auto-generated. Do not edit manually.',
    '#',
    `# version: ${manifest.version}`,
    `# timestamp: ${manifest.timestamp}`,
    '#',
    '# Directories:',
  ];

  // Add directories (sorted)
  for (const dir of [...manifest.directories].sort()) {
    lines.push(dir);
  }

  lines.push('#');
  lines.push('# Files:');

  // Add files (sorted)
  for (const file of [...manifest.files].sort()) {
    lines.push(file);
  }

  return lines.join('\n') + '\n';
}

/**
 * Create a new manifest from generated files
 */
export function createManifest(
  files: string[],
  directories: string[],
  version: string
): Manifest {
  return {
    version,
    timestamp: new Date().toISOString(),
    files: [...new Set(files)].sort(),
    directories: [...new Set(directories)].sort(),
  };
}

/**
 * Read an existing manifest file
 */
export async function readManifest(projectRoot: string): Promise<Result<Manifest | null>> {
  const manifestPath = path.join(projectRoot, MANIFEST_FILENAME);

  if (!(await fileExists(manifestPath))) {
    return ok(null);
  }

  const content = await readFile(manifestPath);
  if (!content.ok) {
    return err(content.error);
  }

  try {
    return ok(parseManifest(content.value));
  } catch (e) {
    return err(new Error(`Failed to parse manifest: ${e instanceof Error ? e.message : String(e)}`));
  }
}

/**
 * Write a manifest file
 */
export async function writeManifest(projectRoot: string, manifest: Manifest): Promise<Result<void>> {
  const manifestPath = path.join(projectRoot, MANIFEST_FILENAME);
  const content = formatManifest(manifest);
  return writeFile(manifestPath, content);
}

/**
 * Collect all generated paths from generate results
 */
export function collectGeneratedPaths(files: string[], projectRoot: string): {
  files: string[];
  directories: string[];
} {
  const fileSet = new Set<string>();
  const dirSet = new Set<string>();

  for (const file of files) {
    // Normalize path to be relative
    const relativePath = path.isAbsolute(file)
      ? path.relative(projectRoot, file)
      : file;

    fileSet.add(relativePath);

    // Extract directory path
    const dirPath = path.dirname(relativePath);
    if (dirPath && dirPath !== '.') {
      // Add the directory with trailing slash
      dirSet.add(dirPath + '/');

      // Also add parent directories for known generated dirs
      for (const knownDir of DEFAULT_GENERATED_DIRECTORIES) {
        const knownDirClean = knownDir.replace(/\/$/, '');
        if (relativePath.startsWith(knownDirClean)) {
          dirSet.add(knownDir);
        }
      }
    }
  }

  return {
    files: [...fileSet].sort(),
    directories: [...dirSet].sort(),
  };
}

/**
 * Get all paths that should be in .gitignore
 */
export function getGitignorePaths(manifest: Manifest): string[] {
  const paths: string[] = [];
  const generatedDirs: string[] = [...DEFAULT_GENERATED_DIRECTORIES];
  const generatedFiles: string[] = [...DEFAULT_GENERATED_FILES];

  // Add directories (these are more efficient to ignore)
  for (const dir of manifest.directories) {
    // Only add top-level generated directories
    if (generatedDirs.includes(dir)) {
      paths.push(dir);
    }
  }

  // Add root-level generated files
  for (const file of manifest.files) {
    if (generatedFiles.includes(file)) {
      paths.push(file);
    }
  }

  // Always include the manifest file itself
  paths.push(MANIFEST_FILENAME);

  return [...new Set(paths)].sort();
}

