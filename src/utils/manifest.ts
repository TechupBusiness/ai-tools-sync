/**
 * @file Manifest Utilities
 * @description Generate and manage .ai-tool-sync-generated manifest file
 *
 * The manifest tracks all files generated by ai-tool-sync, enabling:
 * - Clean up of previously generated files
 * - .gitignore management
 * - Detection of manual edits to generated files
 */

import { createHash } from 'node:crypto';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';

import Ajv, { type ErrorObject } from 'ajv';
import addFormats from 'ajv-formats';

import manifestSchema from '../schemas/manifest.schema.json' assert { type: 'json' };

import { fileExists, readFile, writeFile } from './fs.js';
import { logger } from './logger.js';
import { ok, err, tryCatchAsync, type Result } from './result.js';

/**
 * Name of the manifest file
 */
export const MANIFEST_FILENAME = '.ai-tool-sync-generated';

/**
 * Manifest file entry with hash (v2)
 */
export interface ManifestFileEntry {
  path: string;
  hash: string; // Format: sha256:<64-char-hex>
}

/**
 * Manifest v2 structure with file hashes
 */
export interface ManifestV2 {
  version: '2.0.0';
  timestamp: string;
  files: ManifestFileEntry[];
  directories: string[];
}

/**
 * Default directories that are always generated
 */
export const DEFAULT_GENERATED_DIRECTORIES: readonly string[] = [
  '.cursor/rules/',
  '.cursor/commands/',
  '.claude/',
  '.factory/',
] as const;

/**
 * Default files that may be generated at project root
 */
export const DEFAULT_GENERATED_FILES: readonly string[] = [
  'CLAUDE.md',
  'AGENTS.md',
  'mcp.json',
] as const;

/**
 * Root-level files that may be generated (not inside tool folders)
 */
export const DEFAULT_GENERATED_ROOT_FILES: readonly string[] = [
  ...DEFAULT_GENERATED_FILES,
] as const;

const ajv = new Ajv({ allErrors: true });
addFormats(ajv);
const validateSchema = ajv.compile<ManifestV2>(manifestSchema);

function formatAjvErrors(errors: ErrorObject[] | null | undefined): string {
  if (!errors?.length) {
    return 'Unknown error';
  }

  return errors
    .map((error) => {
      const path = error.instancePath || error.schemaPath || '';
      const message = error.message ?? 'is invalid';
      return path ? `${path} ${message}` : message;
    })
    .join(', ');
}

/**
 * Validate manifest data against the v2 schema
 */
export function validateManifest(data: unknown): Result<ManifestV2> {
  if (validateSchema(data)) {
    return ok(data);
  }

  const errors = formatAjvErrors(validateSchema.errors);
  return err(new Error(`Invalid manifest: ${errors}`));
}

/**
 * Determine if the manifest matches the v2 schema
 */
export function isManifestV2(value: unknown): value is ManifestV2 {
  return validateSchema(value) === true;
}

/**
 * Read an existing manifest file
 */
export async function readManifest(projectRoot: string): Promise<Result<ManifestV2 | null>> {
  const manifestPath = path.join(projectRoot, MANIFEST_FILENAME);

  if (!(await fileExists(manifestPath))) {
    return ok(null);
  }

  const content = await readFile(manifestPath);
  if (!content.ok) {
    return err(content.error);
  }

  let parsed: unknown;
  try {
    parsed = JSON.parse(content.value);
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    return err(new Error(`Failed to parse manifest JSON: ${message}`));
  }

  const validation = validateManifest(parsed);
  if (!validation.ok) {
    return err(validation.error);
  }

  return ok(validation.value);
}

/**
 * Write a manifest file
 */
export async function writeManifest(
  projectRoot: string,
  manifest: ManifestV2
): Promise<Result<void>> {
  const validation = validateManifest(manifest);
  if (!validation.ok) {
    return err(validation.error);
  }

  const manifestPath = path.join(projectRoot, MANIFEST_FILENAME);
  const content = JSON.stringify(validation.value, null, 2) + '\n';
  return writeFile(manifestPath, content);
}

/**
 * Collect all generated paths from generate results
 */
export function collectGeneratedPaths(
  files: string[],
  projectRoot: string
): {
  files: string[];
  directories: string[];
} {
  const fileSet = new Set<string>();
  const dirSet = new Set<string>();

  for (const file of files) {
    const relativePath = path.isAbsolute(file) ? path.relative(projectRoot, file) : file;

    fileSet.add(relativePath);

    const dirPath = path.dirname(relativePath);
    if (dirPath && dirPath !== '.') {
      dirSet.add(`${dirPath}/`);

      for (const knownDir of DEFAULT_GENERATED_DIRECTORIES) {
        const knownDirClean = knownDir.replace(/\/$/, '');
        if (relativePath.startsWith(knownDirClean)) {
          dirSet.add(knownDir);
        }
      }
    }
  }

  return {
    files: [...fileSet].sort(),
    directories: [...dirSet].sort(),
  };
}

/**
 * Get all paths that should be in .gitignore
 */
export function getGitignorePaths(manifest: ManifestV2): string[] {
  const paths: string[] = [];
  const generatedRootFiles: string[] = [...DEFAULT_GENERATED_ROOT_FILES];

  for (const file of manifest.files) {
    if (generatedRootFiles.includes(file.path)) {
      paths.push(file.path);
    }
  }

  paths.push(MANIFEST_FILENAME);

  return [...new Set(paths)].sort();
}

/**
 * Compute SHA256 hash of file contents
 */
export async function computeFileHash(filePath: string): Promise<Result<string>> {
  return tryCatchAsync(async () => {
    const buffer = await fs.readFile(filePath);
    const hash = createHash('sha256').update(buffer).digest('hex');
    return `sha256:${hash}`;
  });
}

/**
 * Check if a file has been modified since generation
 */
export async function isFileModified(
  projectRoot: string,
  entry: ManifestFileEntry
): Promise<Result<boolean>> {
  const filePath = path.join(projectRoot, entry.path);

  if (!(await fileExists(filePath))) {
    return ok(true);
  }

  const hashResult = await computeFileHash(filePath);
  if (!hashResult.ok) {
    return err(hashResult.error);
  }

  return ok(hashResult.value !== entry.hash);
}

/**
 * Create a manifest v2 with file hashes
 */
export function createManifestV2(
  files: ManifestFileEntry[],
  directories: string[],
  version: ManifestV2['version']
): ManifestV2 {
  return {
    version,
    timestamp: new Date().toISOString(),
    files: [...files],
    directories: [...directories],
  };
}

/**
 * Collect file entries with SHA256 hashes
 */
export async function collectFileEntriesWithHashes(
  files: string[],
  projectRoot: string
): Promise<Result<ManifestFileEntry[]>> {
  const entries: ManifestFileEntry[] = [];
  const errors: string[] = [];

  for (const file of files) {
    const filePath = path.join(projectRoot, file);
    const hashResult = await computeFileHash(filePath);

    if (hashResult.ok) {
      entries.push({ path: file, hash: hashResult.value });
    } else {
      const message =
        hashResult.error instanceof Error ? hashResult.error.message : String(hashResult.error);
      errors.push(`Failed to hash ${file}: ${message}`);
    }
  }

  if (errors.length > 0) {
    logger.warn(`Hash collection warnings: ${errors.length} file(s) skipped`);
    for (const error of errors) {
      logger.debug(error);
    }
  }

  return ok(entries);
}

export * from './manifest-history.js';
