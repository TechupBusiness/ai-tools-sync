# T224: Simplify Root Gitignore with Distributed Mode

> **Priority**: P2 | **Wave**: 5 | **Track**: A (Per-Tool Gitignores)
> **Depends on**: T223 (per-tool-folder gitignores)
> **Estimated complexity**: Low

## 1. Objective

Add a `distributed_gitignore` configuration option that, when enabled, simplifies the root `.gitignore` to only contain non-tool-folder generated files (`CLAUDE.md`, `AGENTS.md`, `mcp.json`, `.ai-tool-sync-generated`). Tool folder paths (`.cursor/`, `.claude/`, `.factory/`) are excluded from the root gitignore because T223's per-folder gitignores handle them instead. This creates a cleaner separation of concerns: each tool folder manages its own ignores while the root only manages root-level generated files. Default is `false` for backwards compatibility.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/utils/gitignore.ts` - **Lines 128-143**: `getDefaultGitignorePaths()` returns all paths
- `src/utils/gitignore.ts` - **Lines 147-214**: `updateGitignore()` main function to modify
- `src/utils/manifest.ts` - **Lines 92-110**: `getGitignorePaths()` derives paths from manifest
- `src/cli/commands/sync.ts` - **Lines 487-505**: Integration point in `generateManifestAndGitignore()`
- `src/config/types.ts` - **Lines 99-103**: `OutputConfig` interface to extend
- `src/schemas/config.schema.json` - **Lines 72-93**: Output schema to extend
- `tests/unit/utils/gitignore.test.ts` - **Test patterns** for gitignore utilities

## 3. File Structure

```
src/
├── config/
│   └── types.ts              # Add distributed_gitignore to OutputConfig
├── schemas/
│   └── config.schema.json    # Add distributed_gitignore property
├── utils/
│   ├── gitignore.ts          # Add getRootOnlyGitignorePaths(), modify updateGitignore()
│   └── manifest.ts           # Add getRootOnlyPaths() helper
├── cli/
│   └── commands/
│       └── sync.ts           # Pass distributed_gitignore option, call T223's function
tests/
└── unit/
    └── utils/
        └── gitignore.test.ts # Add tests for distributed mode
```

## 4. Interfaces & Types

### 4.1 Extend OutputConfig (types.ts)

```typescript
// In src/config/types.ts, update OutputConfig:

export interface OutputConfig {
  clean_before_sync?: boolean;
  add_do_not_edit_headers?: boolean;
  update_gitignore?: boolean;
  /** 
   * When true, generate per-tool-folder gitignores (.cursor/.gitignore, etc.)
   * and simplify root .gitignore to only contain root-level generated files.
   * Default: false (for backwards compatibility)
   */
  distributed_gitignore?: boolean;
}
```

### 4.2 New Function Signatures (gitignore.ts)

```typescript
// In src/utils/gitignore.ts

/**
 * Options for updateGitignore
 */
export interface UpdateGitignoreOptions {
  /** Whether to create .gitignore if it doesn't exist */
  createIfMissing?: boolean;
  /** When true, only include root-level paths (not tool folders) */
  distributedMode?: boolean;
}

/**
 * Get paths for root gitignore when in distributed mode
 * Only includes root-level generated files, not tool folder paths
 */
export function getRootOnlyGitignorePaths(): string[];
```

### 4.3 New Helper (manifest.ts)

```typescript
// In src/utils/manifest.ts

/**
 * Get only root-level gitignore paths from manifest
 * Excludes paths within tool folders (.cursor/, .claude/, .factory/)
 */
export function getRootOnlyGitignorePaths(manifest: ManifestV2): string[];
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [ ] Use `Result<T, E>` for error handling (see `src/utils/result.ts`)
- [ ] Extend existing functions, don't duplicate logic
- [ ] Export from `src/utils/index.ts` if adding new public functions
- [ ] Run `npm run lint --fix` after implementation
- [ ] No `any` types
- [ ] Schema must match types exactly

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Tool Folder Detection

```typescript
// ✅ CORRECT - Define tool folders as constants
const TOOL_FOLDERS = ['.cursor', '.claude', '.factory'] as const;

function isInToolFolder(filePath: string): boolean {
  return TOOL_FOLDERS.some(folder => 
    filePath === folder || filePath.startsWith(folder + '/')
  );
}
```

#### 5.2.2 Get Root-Only Paths from Defaults

```typescript
// In src/utils/gitignore.ts

/**
 * Get default paths for root gitignore in distributed mode
 */
export function getRootOnlyGitignorePaths(): string[] {
  // Only root-level files, no tool folders
  return [
    'CLAUDE.md',
    'AGENTS.md',
    'mcp.json',
    MANIFEST_FILENAME,  // .ai-tool-sync-generated
  ];
}
```

#### 5.2.3 Get Root-Only Paths from Manifest

```typescript
// In src/utils/manifest.ts

const TOOL_FOLDERS = ['.cursor', '.claude', '.factory'] as const;

/**
 * Check if a path is within a tool folder
 */
function isInToolFolder(filePath: string): boolean {
  return TOOL_FOLDERS.some(folder => 
    filePath === folder || 
    filePath === folder + '/' ||
    filePath.startsWith(folder + '/')
  );
}

/**
 * Get only root-level gitignore paths from manifest
 * Excludes paths within tool folders (.cursor/, .claude/, .factory/)
 */
export function getRootOnlyGitignorePaths(manifest: ManifestV2): string[] {
  const allPaths = getGitignorePaths(manifest);
  
  // Filter out tool folder paths
  return allPaths.filter(p => !isInToolFolder(p));
}
```

#### 5.2.4 Modify updateGitignore to Support Distributed Mode

```typescript
// In src/utils/gitignore.ts, modify updateGitignore:

export async function updateGitignore(
  projectRoot: string,
  manifest: ManifestV2 | null,
  options: UpdateGitignoreOptions = {}
): Promise<Result<GitignoreUpdateResult>> {
  const gitignorePath = path.join(projectRoot, '.gitignore');
  const exists = await fileExists(gitignorePath);

  // Determine paths to add based on mode
  let paths: string[];
  if (options.distributedMode) {
    // Only root-level files when distributed mode is enabled
    paths = manifest
      ? getRootOnlyGitignorePathsFromManifest(manifest)  // from manifest.ts
      : getRootOnlyGitignorePaths();  // defaults from gitignore.ts
  } else {
    // All paths (backwards compatible default)
    paths = manifest
      ? getGitignorePaths(manifest)
      : getDefaultGitignorePaths();
  }

  // ... rest of the function remains the same
}
```

### 5.3 Edge Cases to Handle

- [ ] `distributed_gitignore: true` with no manifest → Use root-only default paths
- [ ] `distributed_gitignore: true` with manifest → Filter manifest to root-only paths
- [ ] `distributed_gitignore: false` (default) → Current behavior, all paths in root gitignore
- [ ] No tool folders generated (single target) → Root gitignore still works correctly
- [ ] Switching from non-distributed to distributed → Old tool folder paths remain in gitignore (manual cleanup needed, documented)
- [ ] Empty root-only paths (all files in tool folders) → Still create managed section with just manifest filename

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/utils/gitignore.test.ts - ADD to existing file

describe('Distributed Gitignore Mode', () => {
  describe('getRootOnlyGitignorePaths', () => {
    it('should return only root-level paths', () => { /* ... */ });
    it('should include manifest filename', () => { /* ... */ });
    it('should not include tool folder paths', () => { /* ... */ });
  });

  describe('updateGitignore with distributedMode', () => {
    it('should exclude tool folder paths when distributedMode is true', async () => { /* ... */ });
    it('should include all paths when distributedMode is false', async () => { /* ... */ });
    it('should handle manifest with only tool folder files', async () => { /* ... */ });
  });
});
```

### 6.2 Required Test Cases

```typescript
// Test: Root-only default paths exclude tool folders
it('should return only root-level default paths', () => {
  const paths = getRootOnlyGitignorePaths();
  
  expect(paths).toContain('CLAUDE.md');
  expect(paths).toContain('AGENTS.md');
  expect(paths).toContain('mcp.json');
  expect(paths).toContain('.ai-tool-sync-generated');
  
  // Should NOT contain tool folder paths
  expect(paths).not.toContain('.cursor/');
  expect(paths).not.toContain('.cursor/rules/');
  expect(paths).not.toContain('.claude/');
  expect(paths).not.toContain('.factory/');
});

// Test: Manifest filtering excludes tool folder paths
it('should filter manifest to root-only paths', () => {
  const manifest: ManifestV2 = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: [
      { path: '.cursor/rules/core.mdc', hash: 'sha256:abc' },
      { path: '.claude/skills/test/SKILL.md', hash: 'sha256:def' },
      { path: 'CLAUDE.md', hash: 'sha256:ghi' },
      { path: 'AGENTS.md', hash: 'sha256:jkl' },
      { path: 'mcp.json', hash: 'sha256:mno' },
    ],
    directories: ['.cursor/rules/', '.claude/skills/'],
  };
  
  const paths = getRootOnlyGitignorePathsFromManifest(manifest);
  
  // Should contain root-level files
  expect(paths).toContain('CLAUDE.md');
  expect(paths).toContain('AGENTS.md');
  expect(paths).toContain('mcp.json');
  expect(paths).toContain('.ai-tool-sync-generated');
  
  // Should NOT contain tool folder paths
  expect(paths).not.toContain('.cursor/rules/');
  expect(paths).not.toContain('.cursor/rules/core.mdc');
  expect(paths).not.toContain('.claude/skills/');
});

// Test: updateGitignore respects distributedMode
it('should use root-only paths when distributedMode is true', async () => {
  const testDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gitignore-test-'));
  
  // Create existing gitignore
  await fs.writeFile(
    path.join(testDir, '.gitignore'),
    '# User content\n*.log\n'
  );
  
  const manifest: ManifestV2 = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: [
      { path: '.cursor/rules/core.mdc', hash: 'sha256:abc' },
      { path: 'CLAUDE.md', hash: 'sha256:def' },
    ],
    directories: ['.cursor/rules/'],
  };
  
  await updateGitignore(testDir, manifest, { distributedMode: true });
  
  const content = await fs.readFile(path.join(testDir, '.gitignore'), 'utf8');
  
  // Should contain root-level paths
  expect(content).toContain('CLAUDE.md');
  expect(content).toContain('.ai-tool-sync-generated');
  
  // Should NOT contain tool folder paths
  expect(content).not.toContain('.cursor/');
  expect(content).not.toContain('.cursor/rules/');
  
  // User content preserved
  expect(content).toContain('*.log');
  
  await fs.rm(testDir, { recursive: true });
});

// Test: Default mode includes all paths (backwards compat)
it('should include all paths when distributedMode is false (default)', async () => {
  const testDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gitignore-test-'));
  
  const manifest: ManifestV2 = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: [
      { path: '.cursor/rules/core.mdc', hash: 'sha256:abc' },
      { path: 'CLAUDE.md', hash: 'sha256:def' },
    ],
    directories: ['.cursor/rules/'],
  };
  
  await updateGitignore(testDir, manifest, { createIfMissing: true });
  
  const content = await fs.readFile(path.join(testDir, '.gitignore'), 'utf8');
  
  // Should contain all paths
  expect(content).toContain('CLAUDE.md');
  expect(content).toContain('.cursor/rules/');
  
  await fs.rm(testDir, { recursive: true });
});
```

## 7. Integration Points

- **Imports from**:
  - `src/utils/manifest.ts` - `getGitignorePaths`, `ManifestV2`, `MANIFEST_FILENAME`
  - `src/utils/fs.ts` - `fileExists`, `readFile`, `writeFile`
  - `src/utils/result.ts` - `Result`, `ok`, `err`

- **Exports to**:
  - `src/cli/commands/sync.ts` - uses `updateGitignore()` with `distributedMode` option

- **Integration in sync.ts**:

```typescript
// In generateManifestAndGitignore(), around line 488-505

// Update .gitignore if enabled
const shouldUpdateGitignore = options.updateGitignore ?? config.output?.update_gitignore ?? true;
const distributedGitignore = config.output?.distributed_gitignore ?? false;

if (shouldUpdateGitignore) {
  // When distributed mode is enabled, also update tool folder gitignores (T223)
  if (distributedGitignore) {
    const toolFolderResult = await updateToolFolderGitignores(
      config.projectRoot,
      manifest,
      { dryRun: options.dryRun }
    );
    
    if (toolFolderResult.ok) {
      for (const folderResult of toolFolderResult.value) {
        if (folderResult.changed) {
          logger.debug(`Updated ${folderResult.folder}/.gitignore`);
        }
      }
    } else {
      result.warnings.push(`Failed to update tool folder gitignores: ${toolFolderResult.error.message}`);
    }
  }

  // Update root gitignore (with distributed mode if enabled)
  const gitignoreResult = await updateGitignore(config.projectRoot, manifest, {
    createIfMissing: false,
    distributedMode: distributedGitignore,
  });

  if (gitignoreResult.ok) {
    if (gitignoreResult.value.changed) {
      result.gitignoreUpdated = true;
      printSuccess('.gitignore updated with generated paths');
    }
  } else {
    result.warnings.push(`Failed to update .gitignore: ${gitignoreResult.error.message}`);
  }
}
```

- **Schema changes** (config.schema.json):

```json
"output": {
  "type": "object",
  "description": "Output generation settings",
  "properties": {
    "clean_before_sync": { /* ... */ },
    "add_do_not_edit_headers": { /* ... */ },
    "update_gitignore": { /* ... */ },
    "distributed_gitignore": {
      "type": "boolean",
      "description": "Generate per-tool-folder gitignores and simplify root gitignore",
      "default": false
    }
  },
  "additionalProperties": false
}
```

## 8. Acceptance Criteria

- [ ] `distributed_gitignore` option added to `OutputConfig` type
- [ ] `distributed_gitignore` property added to JSON schema
- [ ] `getRootOnlyGitignorePaths()` returns only root-level default paths
- [ ] `getRootOnlyGitignorePathsFromManifest()` filters manifest to root-only paths
- [ ] `updateGitignore()` accepts `distributedMode` option
- [ ] When `distributedMode: true`, root gitignore excludes tool folder paths
- [ ] sync.ts calls T223's `updateToolFolderGitignores()` when distributed mode enabled
- [ ] All tests pass (`npm test -- gitignore.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Migration tool to convert from non-distributed to distributed gitignore (future task)
- Automatic cleanup of old tool folder entries from root gitignore (user must manually remove)
- Per-target gitignore opt-out (e.g., distributed for Cursor but not Claude)
- The actual per-tool-folder gitignore generation (handled by T223)

## 10. Implementation Checklist

1. [ ] Add `distributed_gitignore` to `OutputConfig` in `src/config/types.ts`
2. [ ] Add `distributed_gitignore` property to `output` in `src/schemas/config.schema.json`
3. [ ] Add `TOOL_FOLDERS` constant to `src/utils/manifest.ts`
4. [ ] Add `isInToolFolder()` helper to `src/utils/manifest.ts`
5. [ ] Add `getRootOnlyGitignorePaths()` to `src/utils/manifest.ts`
6. [ ] Export new function from `src/utils/manifest.ts`
7. [ ] Add `distributedMode` option to `UpdateGitignoreOptions` in `src/utils/gitignore.ts`
8. [ ] Add `getRootOnlyGitignorePaths()` default function to `src/utils/gitignore.ts`
9. [ ] Modify `updateGitignore()` to handle `distributedMode` option
10. [ ] Update `src/cli/commands/sync.ts` to pass `distributedMode` and call T223's function
11. [ ] Add tests to `tests/unit/utils/gitignore.test.ts`
12. [ ] Add tests to `tests/unit/utils/manifest.test.ts` for new manifest helper
13. [ ] Run `npm test -- gitignore.test.ts manifest.test.ts`
14. [ ] Run `npm run lint --fix`
15. [ ] Run `npm run typecheck`
16. [ ] Update plan.md with T224 completion status

## 11. Example Configuration

```yaml
# .ai-tool-sync/config.yaml
version: "1.0.0"
project_name: my-project

targets:
  - cursor
  - claude
  - factory

output:
  update_gitignore: true
  distributed_gitignore: true  # Enable per-folder gitignores
```

## 12. Example Output

With `distributed_gitignore: true`, the gitignore structure becomes:

```
project/
├── .gitignore                    # Root: only CLAUDE.md, AGENTS.md, mcp.json, manifest
│                                 # (no .cursor/, .claude/, .factory/ paths)
├── .cursor/
│   └── .gitignore                # Auto-managed: rules/, commands/, hooks.json (T223)
├── .claude/
│   └── .gitignore                # Auto-managed: skills/, agents/, commands/ (T223)
└── .factory/
    └── .gitignore                # Auto-managed: skills/, droids/, commands/ (T223)
```

**Root `.gitignore` content (distributed mode):**

```gitignore
# User additions preserved

# >>> AI Tool Sync Generated (auto-managed) >>>
.ai-tool-sync-generated
AGENTS.md
CLAUDE.md
mcp.json
# <<< AI Tool Sync Generated <<<
```

**Root `.gitignore` content (non-distributed mode, default):**

```gitignore
# User additions preserved

# >>> AI Tool Sync Generated (auto-managed) >>>
.ai-tool-sync-generated
.claude/
.cursor/commands/
.cursor/rules/
.factory/
AGENTS.md
CLAUDE.md
mcp.json
# <<< AI Tool Sync Generated <<<
```

