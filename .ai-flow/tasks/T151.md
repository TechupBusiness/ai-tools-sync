# T151: Implement Plugin Update Mechanism

> **Priority**: P2 | **Wave**: 2 | **Track**: A (Plugin Infrastructure)
> **Depends on**: T150 (plugin caching) ‚úÖ, T158 (Git-based plugin loader) ‚è≥
> **Estimated complexity**: Medium-High

## 1. Objective

Implement a plugin update mechanism that allows users to check for and update outdated plugins. The mechanism detects available updates by querying Git remote tags, compares them with cached versions, and provides a CLI command (`ai-sync plugins update [name]`) to update plugins to their latest versions. Only exact version pins are supported (no semver ranges), following Claude plugin marketplace conventions.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:

- `src/utils/plugin-cache.ts` lines 178-400 - **PluginCache class** for cache management, manifest handling, and plugin entry operations
- `src/loaders/git.ts` lines 212-790 - **GitLoader** for Git operations, version detection, and repository fetching
- `src/loaders/git.ts` lines 715-751 - **fetchRepo method** - Copy pattern for fetching latest from remote
- `src/cli/commands/sync.ts` lines 65-90 - **CLI command options pattern**
- `tests/unit/utils/plugin-cache.test.ts` - **Test patterns for plugin cache operations**

## 3. File Structure

```
src/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ plugin-update.ts      # NEW: Update detection and execution logic
‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îî‚îÄ‚îÄ commands/
‚îÇ       ‚îî‚îÄ‚îÄ plugins.ts        # NEW: `ai-sync plugins` subcommand
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ plugin-update.test.ts  # NEW: Unit tests for update logic
‚îî‚îÄ‚îÄ integration/
    ‚îî‚îÄ‚îÄ plugin-update.test.ts      # NEW: Integration tests with Git mocks
```

## 4. Interfaces & Types

```typescript
// src/utils/plugin-update.ts

import type { Result } from './result.js';
import type { PluginCacheEntry, PluginCache } from './plugin-cache.js';

/**
 * Available version information for a plugin
 */
export interface PluginVersionInfo {
  /** Current cached version (null if not cached) */
  currentVersion: string | null;
  /** Latest available version from remote */
  latestVersion: string | null;
  /** All available versions (sorted, newest first) */
  availableVersions: string[];
  /** Whether an update is available */
  hasUpdate: boolean;
}

/**
 * Result of checking for updates on a single plugin
 */
export interface PluginUpdateCheck {
  /** Plugin source string */
  source: string;
  /** Plugin ID from cache */
  pluginId: string;
  /** Version information */
  versions: PluginVersionInfo;
  /** Error message if check failed */
  error?: string;
}

/**
 * Result of updating a plugin
 */
export interface PluginUpdateResult {
  /** Plugin source string */
  source: string;
  /** Plugin ID */
  pluginId: string;
  /** Previous version */
  previousVersion: string | null;
  /** New version after update */
  newVersion: string;
  /** Whether update was successful */
  success: boolean;
  /** Error message if update failed */
  error?: string;
}

/**
 * Options for the update check
 */
export interface UpdateCheckOptions {
  /** Base directory for plugin cache (default: .ai-tool-sync) */
  baseDir?: string;
  /** Timeout for Git operations in ms (default: 30000) */
  timeout?: number;
}

/**
 * Options for the update command
 */
export interface UpdateOptions extends UpdateCheckOptions {
  /** Whether to actually update (false = dry run) */
  apply?: boolean;
  /** Force update even if already on latest */
  force?: boolean;
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [ ] Use `Result<T, E>` for all operations that can fail (see `src/utils/result.ts`)
- [ ] Use `logger` from `src/utils/logger.js` for debug output
- [ ] Export only from `index.ts` (add to `src/index.ts` and `src/utils/index.ts`)
- [ ] Use existing `PluginCache` class - don't duplicate cache management
- [ ] Follow existing CLI output patterns from `src/cli/output.ts`
- [ ] Only support exact version pins (e.g., `v1.0.0`) - no semver ranges

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Fetching Remote Tags

```typescript
// ‚ùå WRONG - Cloning entire repo to get tags
const tags = await cloneAndListTags(repoUrl);

// ‚úÖ CORRECT - Use ls-remote to fetch tags without cloning
export async function fetchRemoteTags(repoUrl: string, timeout?: number): Promise<Result<string[]>> {
  const command = `git ls-remote --tags --refs ${repoUrl}`;
  
  try {
    const { stdout } = await execAsync(command, {
      timeout: timeout ?? 30000,
      env: {
        ...process.env,
        GIT_TERMINAL_PROMPT: '0', // Disable interactive prompts
      },
    });
    
    // Parse output: "sha\trefs/tags/v1.0.0"
    const tags = stdout
      .split('\n')
      .filter(Boolean)
      .map(line => {
        const match = line.match(/refs\/tags\/(.+)$/);
        return match?.[1];
      })
      .filter((tag): tag is string => tag !== undefined);
    
    return ok(tags);
  } catch (error) {
    return err(new Error(`Failed to fetch tags: ${error instanceof Error ? error.message : String(error)}`));
  }
}
```

#### 5.2.2 Version Comparison

```typescript
// ‚ùå WRONG - String comparison doesn't handle semver correctly
const hasUpdate = latestVersion > currentVersion;

// ‚úÖ CORRECT - Proper semver comparison (only exact versions)
import { compareVersions } from '../utils/version.js';

function hasNewerVersion(current: string | null, latest: string | null): boolean {
  if (!latest) return false;
  if (!current) return true;
  
  // Normalize versions (strip 'v' prefix)
  const normalizedCurrent = current.replace(/^v/, '');
  const normalizedLatest = latest.replace(/^v/, '');
  
  // Use semver comparison if both are valid semver, else string comparison
  try {
    return compareVersions(normalizedLatest, normalizedCurrent) > 0;
  } catch {
    return normalizedLatest !== normalizedCurrent;
  }
}
```

#### 5.2.3 Preserving Local Configuration

```typescript
// ‚ùå WRONG - Blindly replace entire cache directory
await fs.rm(pluginPath, { recursive: true });
await cloneRepo(source, pluginPath, latestVersion);

// ‚úÖ CORRECT - Preserve local overrides during update
export async function updatePlugin(
  cache: PluginCache,
  source: string,
  newVersion: string,
  options?: UpdateOptions
): Promise<Result<PluginUpdateResult>> {
  const entry = cache.getCacheEntry(source);
  const pluginPath = cache.getPluginPath(entry?.id ?? generatePluginId(source));
  
  // Check for local overrides (files user may have modified)
  const localOverridesPath = path.join(pluginPath, '.local-overrides');
  let hadOverrides = false;
  
  if (await dirExists(localOverridesPath)) {
    hadOverrides = true;
    // Move to temp location
    await fs.rename(localOverridesPath, `${localOverridesPath}.backup`);
  }
  
  // Invalidate old cache and fetch new version
  await cache.invalidate(source, entry?.version);
  
  // Clone/fetch new version (use GitLoader)
  const gitLoader = new GitLoader();
  const loadResult = await gitLoader.load(source, {
    cacheDir: cache.getCacheDir(),
    forceRefresh: true,
  });
  
  // Restore local overrides if they existed
  if (hadOverrides) {
    await fs.rename(`${localOverridesPath}.backup`, localOverridesPath);
  }
  
  // Re-cache with new version
  await cache.cachePlugin(source, newVersion, pluginPath);
  
  return ok({
    source,
    pluginId: entry?.id ?? generatePluginId(source, newVersion),
    previousVersion: entry?.version ?? null,
    newVersion,
    success: true,
  });
}
```

### 5.3 Edge Cases to Handle

- [ ] Plugin has no cached version ‚Üí Check for updates from source URL, offer to install
- [ ] Remote has no tags ‚Üí Return error "No version tags found"
- [ ] Already on latest version ‚Üí Return `hasUpdate: false`, skip update
- [ ] Network error fetching tags ‚Üí Return error with message, don't crash
- [ ] Invalid source format ‚Üí Return error "Invalid plugin source"
- [ ] Plugin source is local path (not Git) ‚Üí Skip update check, return "Local plugins cannot be updated"
- [ ] Git command not available ‚Üí Return error "Git is required for plugin updates"
- [ ] Version format inconsistent (with/without 'v' prefix) ‚Üí Normalize before comparison
- [ ] Multiple plugins to update ‚Üí Process sequentially, collect all results
- [ ] Update specific plugin by name ‚Üí Filter by source or plugin ID match
- [ ] `--force` flag ‚Üí Re-download even if version matches

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/utils/plugin-update.test.ts
describe('plugin-update', () => {
  describe('fetchRemoteTags()', () => { /* ... */ });
  describe('hasNewerVersion()', () => { /* ... */ });
  describe('checkForUpdates()', () => { /* ... */ });
  describe('updatePlugin()', () => { /* ... */ });
});

// tests/integration/plugin-update.test.ts
describe('plugin update integration', () => {
  describe('end-to-end update flow', () => { /* ... */ });
  describe('CLI plugins update command', () => { /* ... */ });
});
```

### 6.2 Required Test Cases

#### Unit Tests

- [ ] **fetchRemoteTags** - Parses `git ls-remote` output correctly

```typescript
it('should parse git ls-remote output correctly', async () => {
  vi.mocked(execAsync).mockResolvedValue({
    stdout: `abc123\trefs/tags/v1.0.0\ndef456\trefs/tags/v1.1.0\nghi789\trefs/tags/v2.0.0`,
    stderr: '',
  });
  
  const result = await fetchRemoteTags('https://github.com/owner/repo.git');
  
  expect(result.ok).toBe(true);
  expect(result.value).toEqual(['v1.0.0', 'v1.1.0', 'v2.0.0']);
});
```

- [ ] **hasNewerVersion** - Version comparison edge cases

```typescript
it('should correctly compare semver versions', () => {
  expect(hasNewerVersion('v1.0.0', 'v1.0.1')).toBe(true);
  expect(hasNewerVersion('v1.0.0', 'v1.0.0')).toBe(false);
  expect(hasNewerVersion('v2.0.0', 'v1.9.9')).toBe(false);
  expect(hasNewerVersion(null, 'v1.0.0')).toBe(true);  // No current = needs update
  expect(hasNewerVersion('v1.0.0', null)).toBe(false); // No latest = no update
});

it('should handle versions with and without v prefix', () => {
  expect(hasNewerVersion('1.0.0', 'v1.0.1')).toBe(true);
  expect(hasNewerVersion('v1.0.0', '1.0.1')).toBe(true);
});
```

- [ ] **checkForUpdates** - Single plugin check

```typescript
it('should detect when update is available', async () => {
  // Setup: plugin cached at v1.0.0, remote has v1.1.0
  const cache = await setupTestCache({ 'github:owner/repo': 'v1.0.0' });
  vi.mocked(fetchRemoteTags).mockResolvedValue(ok(['v1.0.0', 'v1.1.0']));
  
  const result = await checkForUpdates(cache, 'github:owner/repo');
  
  expect(result.ok).toBe(true);
  expect(result.value.hasUpdate).toBe(true);
  expect(result.value.versions.currentVersion).toBe('v1.0.0');
  expect(result.value.versions.latestVersion).toBe('v1.1.0');
});
```

- [ ] **updatePlugin** - Successful update flow

```typescript
it('should update plugin to latest version', async () => {
  const cache = await setupTestCache({ 'github:owner/repo': 'v1.0.0' });
  
  const result = await updatePlugin(cache, 'github:owner/repo', 'v1.1.0');
  
  expect(result.ok).toBe(true);
  expect(result.value.previousVersion).toBe('v1.0.0');
  expect(result.value.newVersion).toBe('v1.1.0');
  expect(result.value.success).toBe(true);
  
  // Verify cache updated
  const entry = cache.getCacheEntry('github:owner/repo', 'v1.1.0');
  expect(entry).not.toBeNull();
  expect(entry?.version).toBe('v1.1.0');
});
```

- [ ] **Error handling** - Network failure

```typescript
it('should handle network errors gracefully', async () => {
  const cache = await setupTestCache({ 'github:owner/repo': 'v1.0.0' });
  vi.mocked(execAsync).mockRejectedValue(new Error('Network timeout'));
  
  const result = await checkForUpdates(cache, 'github:owner/repo');
  
  expect(result.ok).toBe(false);
  expect(result.error.message).toContain('Network timeout');
});
```

- [ ] **Local plugin** - Cannot update local paths

```typescript
it('should return error for local plugin sources', async () => {
  const result = await checkForUpdates(cache, './local/plugin');
  
  expect(result.ok).toBe(false);
  expect(result.error.message).toContain('Local plugins cannot be updated');
});
```

### 6.3 Integration Tests

- [ ] End-to-end update with real Git operations (use test fixtures repo)
- [ ] CLI `ai-sync plugins update` command output
- [ ] Multiple plugins update in sequence
- [ ] Dry-run mode (`--dry-run`) shows what would be updated

## 7. Integration Points

- **Imports from**:
  - `src/utils/plugin-cache.ts` - `PluginCache`, `generatePluginId`, `PluginCacheEntry`
  - `src/utils/result.ts` - `Result`, `ok`, `err`
  - `src/utils/fs.ts` - `dirExists`, `ensureDir`
  - `src/utils/logger.ts` - `logger`
  - `src/loaders/git.ts` - `GitLoader`, `parseGitSource`, `isGitAvailable`
  
- **Exports to**: 
  - Will be used by `src/cli/commands/plugins.ts`
  - Will be exposed via `src/index.ts` for programmatic use
  
- **Config**: 
  - Read `plugins` section from `config.yaml` for plugin sources
  - No new config schema changes needed

## 8. CLI Command Specification

### 8.1 Command Structure

```bash
# Check for updates (dry-run by default)
ai-sync plugins update
ai-sync plugins update --all

# Update specific plugin
ai-sync plugins update <plugin-name-or-source>

# Actually apply updates
ai-sync plugins update --apply
ai-sync plugins update my-plugin --apply

# Force re-download even if up to date
ai-sync plugins update --force --apply
```

### 8.2 CLI Output Format

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AI Tool Sync - Plugin Updates          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Checking for updates...

  üì¶ anthropic/example-plugin
     Current: v1.0.0 ‚Üí Latest: v1.2.0 ‚ú® Update available

  üì¶ company/internal-rules  
     Current: v2.3.1 ‚Üí Latest: v2.3.1 ‚úì Up to date

  üì¶ other/plugin
     ‚ö† Error: Failed to fetch tags (network timeout)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Summary: 1 update available, 1 up to date, 1 error

Run with --apply to install updates
```

### 8.3 CLI Implementation Pattern

```typescript
// src/cli/commands/plugins.ts
import { Command } from 'commander';
import { printHeader, printSuccess, printWarning, printError } from '../output.js';
import { checkAllPluginsForUpdates, updatePlugin } from '../../utils/plugin-update.js';
import { createPluginCache } from '../../utils/plugin-cache.js';

export function createPluginsCommand(): Command {
  const plugins = new Command('plugins')
    .description('Manage plugins');

  plugins
    .command('update [name]')
    .description('Check for and install plugin updates')
    .option('--apply', 'Actually apply updates (default: dry-run)')
    .option('--force', 'Force re-download even if up to date')
    .option('--all', 'Update all plugins')
    .action(async (name, options) => {
      // Implementation here - follow sync.ts patterns
    });

  plugins
    .command('list')
    .description('List installed plugins')
    .action(async () => {
      // List cached plugins
    });

  return plugins;
}
```

## 9. Acceptance Criteria

- [ ] `ai-sync plugins update` shows available updates for all cached plugins
- [ ] `ai-sync plugins update <name>` filters to specific plugin
- [ ] `ai-sync plugins update --apply` actually updates plugins
- [ ] Updates preserve local overrides in `.local-overrides/` directory
- [ ] Network errors are handled gracefully with clear error messages
- [ ] Local plugin paths return clear "cannot update" message
- [ ] All tests pass (`npm test -- plugin-update`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Exports added to `src/index.ts`

## 10. Out of Scope

- Semver range support (e.g., `^1.0.0`) - only exact pins
- Automatic updates on `ai-sync` - manual `plugins update` only
- Plugin removal command (handled in T160)
- Plugin add command (handled in T160)
- Git-based plugin loader implementation (handled in T158 - T151 depends on it)

## 11. Implementation Checklist

1. [ ] Create `src/utils/plugin-update.ts` with core functions
2. [ ] Implement `fetchRemoteTags()` using `git ls-remote`
3. [ ] Implement `checkForUpdates()` for single plugin
4. [ ] Implement `checkAllPluginsForUpdates()` for all cached plugins
5. [ ] Implement `updatePlugin()` with cache invalidation and re-fetch
6. [ ] Create `src/cli/commands/plugins.ts` with `update` subcommand
7. [ ] Add `plugins` command to main CLI in `src/cli/index.ts`
8. [ ] Write unit tests in `tests/unit/utils/plugin-update.test.ts`
9. [ ] Write integration tests in `tests/integration/plugin-update.test.ts`
10. [ ] Add exports to `src/index.ts`
11. [ ] Run `npm test` to verify all tests pass
12. [ ] Run `npm run lint` to verify no lint errors

## 12. Notes

- This task depends on T158 (Git-based plugin loader) for the actual cloning/fetching logic
- The `git ls-remote` approach is efficient - no need to clone repos just to check versions
- Only GitHub, GitLab, and Bitbucket sources can be updated (they have Git tags)
- npm/pip plugins would need different version checking (not in scope for T151)

