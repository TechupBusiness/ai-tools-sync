# T158: Implement Git-Based Plugin Loader

> **Priority**: P2 | **Wave**: 2 | **Track**: A (Plugin Infrastructure)
> **Depends on**: T150
> **Estimated complexity**: High

## 1. Objective

Create a new `PluginLoader` that supports Claude Code marketplace-style plugin URLs (`github:owner/repo@version`). This enables users to reference plugins from Git repositories in their `config.yaml`, with automatic cloning, version-based caching, and content loading via the existing claude-plugin loader. This is the foundation for the plugin ecosystem integration.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/loaders/git.ts` - **Git cloning and caching patterns** (adapt, don't duplicate)
- `src/loaders/claude-plugin.ts` - **Plugin content loading** (delegate to this after cloning)
- `src/utils/plugin-cache.ts` - **Version-aware caching** (use existing infrastructure)
- `tests/unit/loaders/git.test.ts` - **Git loader test patterns**
- `targets/` yaml files - **Target mapping pattern** for reference

## 3. File Structure

```
src/
├── loaders/
│   ├── plugin.ts             # NEW: Plugin loader (Git-based)
│   └── index.ts              # Export new loader
tests/
├── fixtures/
│   └── plugins/              # NEW: Mock plugin repos for testing
│       └── test-plugin/
│           ├── plugin.json
│           └── skills/
└── unit/
    └── loaders/
        └── plugin.test.ts    # NEW: Plugin loader tests
```

## 4. Interfaces & Types

```typescript
// In src/loaders/plugin.ts

import type { Loader, LoaderOptions, LoadResult } from './base.js';
import type { PluginCache } from '../utils/plugin-cache.js';

/**
 * Plugin source prefixes
 */
export const PLUGIN_PREFIXES = ['plugin:', 'github:', 'gitlab:', 'bitbucket:'] as const;
export type PluginPrefix = (typeof PLUGIN_PREFIXES)[number];

/**
 * Parsed plugin source
 */
export interface ParsedPluginSource {
  /** Full clone URL */
  cloneUrl: string;
  /** Hosting provider (github.com, gitlab.com, etc.) */
  host: string;
  /** Repository owner/organization */
  owner: string;
  /** Repository name */
  repo: string;
  /** Version (tag or branch) - exact pins only, no ranges */
  version?: string;
  /** Subpath within the repository */
  subpath?: string;
  /** Original source string */
  original: string;
}

/**
 * Plugin loader options
 */
export interface PluginLoaderOptions extends LoaderOptions {
  /**
   * Plugin cache instance
   */
  pluginCache?: PluginCache;

  /**
   * Cache directory (default: .ai-tool-sync/plugins/)
   */
  cacheDir?: string;

  /**
   * Force refresh (ignore cache, re-clone)
   */
  forceRefresh?: boolean;

  /**
   * Git timeout in milliseconds (default: 5 minutes)
   */
  timeout?: number;

  /**
   * Personal access token for private repos
   */
  token?: string;
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Implement `Loader` interface from `src/loaders/base.ts`
- [x] Use `PluginCache` from `src/utils/plugin-cache.ts` for caching
- [x] Delegate content loading to `ClaudePluginLoader` after cloning
- [x] Use `Result<T, E>` for error handling internally
- [x] Support exact version pins only (no semver ranges like `^1.0.0`)
- [x] Export from `src/loaders/index.ts`

### 5.2 Critical Logic (Pitfall Prevention)

**Loader Class Structure:**

```typescript
/**
 * Loader for Git-based Claude Code plugins (marketplace style)
 */
export class PluginLoader implements Loader {
  readonly name = 'plugin';

  private claudePluginLoader: ClaudePluginLoader;
  private pluginCache: PluginCache | null = null;

  constructor() {
    this.claudePluginLoader = new ClaudePluginLoader();
  }

  canLoad(source: string): boolean {
    // Handle: github:owner/repo, gitlab:owner/repo, plugin:github:owner/repo
    for (const prefix of PLUGIN_PREFIXES) {
      if (source.startsWith(prefix)) {
        return true;
      }
    }
    return false;
  }

  async load(source: string, options?: PluginLoaderOptions): Promise<LoadResult> {
    // 1. Parse source URL
    const parsed = this.parseSource(source);
    if (!parsed) {
      return {
        ...emptyLoadResultWithSource(source),
        errors: [{ type: 'file', path: source, message: 'Invalid plugin source format' }],
      };
    }

    // 2. Initialize cache if provided
    if (options?.pluginCache) {
      this.pluginCache = options.pluginCache;
    } else if (options?.cacheDir) {
      const cacheResult = await createPluginCache(options.cacheDir);
      if (cacheResult.ok) {
        this.pluginCache = cacheResult.value;
      }
    }

    // 3. Check cache for existing clone
    const pluginPath = await this.ensurePluginCloned(parsed, options);
    if (!pluginPath) {
      return {
        ...emptyLoadResultWithSource(source),
        errors: [{ type: 'directory', path: source, message: 'Failed to clone plugin repository' }],
      };
    }

    // 4. Delegate to ClaudePluginLoader for content loading
    const result = await this.claudePluginLoader.load(
      `claude-plugin:${pluginPath}`,
      {
        ...options,
        basePath: pluginPath,
        pluginCache: this.pluginCache ?? undefined,
        version: parsed.version,
      }
    );

    // 5. Update source to original plugin URL
    result.source = source;

    return result;
  }
}
```

**Source Parsing:**

```typescript
/**
 * Parse plugin source to extract components
 * 
 * Supported formats:
 * - github:owner/repo
 * - github:owner/repo@v1.0.0
 * - github:owner/repo/subpath@v1.0.0
 * - gitlab:owner/repo@1.0.0
 * - bitbucket:owner/repo@tag
 * - plugin:github:owner/repo@v1.0.0 (explicit plugin prefix)
 */
parseSource(source: string): ParsedPluginSource | null {
  let normalized = source;

  // Remove plugin: prefix if present
  if (normalized.startsWith('plugin:')) {
    normalized = normalized.slice(7);
  }

  // Determine host from prefix
  let host: string;
  let remainder: string;

  if (normalized.startsWith('github:')) {
    host = 'github.com';
    remainder = normalized.slice(7);
  } else if (normalized.startsWith('gitlab:')) {
    host = 'gitlab.com';
    remainder = normalized.slice(7);
  } else if (normalized.startsWith('bitbucket:')) {
    host = 'bitbucket.org';
    remainder = normalized.slice(10);
  } else {
    return null;
  }

  // Parse: owner/repo[/subpath][@version]
  const versionSplit = remainder.split('@');
  const pathPart = versionSplit[0] ?? '';
  const version = versionSplit[1]; // undefined if no @

  const pathParts = pathPart.split('/');
  if (pathParts.length < 2) {
    return null;
  }

  const owner = pathParts[0] ?? '';
  const repo = pathParts[1] ?? '';
  const subpath = pathParts.length > 2 ? pathParts.slice(2).join('/') : undefined;

  // Build clone URL (always HTTPS)
  const cloneUrl = `https://${host}/${owner}/${repo}.git`;

  return {
    cloneUrl,
    host,
    owner,
    repo,
    version: version || undefined,
    subpath,
    original: source,
  };
}
```

**Cloning with Cache:**

```typescript
/**
 * Ensure plugin is cloned and return path
 */
private async ensurePluginCloned(
  parsed: ParsedPluginSource,
  options?: PluginLoaderOptions
): Promise<string | null> {
  const pluginId = generatePluginId(parsed.original, parsed.version);
  
  // Check cache first
  if (this.pluginCache && !options?.forceRefresh) {
    if (await this.pluginCache.isCached(parsed.original, parsed.version)) {
      const entry = this.pluginCache.getCacheEntry(parsed.original, parsed.version);
      if (entry) {
        const cachedPath = this.pluginCache.getPluginPath(entry.id);
        await this.pluginCache.touchPlugin(parsed.original, parsed.version);
        logger.debug(`Using cached plugin: ${cachedPath}`);
        return cachedPath;
      }
    }
  }

  // Clone the repository
  const cacheDir = options?.cacheDir ?? '.ai-tool-sync';
  const pluginPath = path.join(cacheDir, 'plugins', pluginId);

  try {
    await this.clonePlugin(parsed, pluginPath, options);

    // Update cache
    if (this.pluginCache) {
      await this.pluginCache.cachePlugin(parsed.original, parsed.version, pluginPath);
    }

    return pluginPath;
  } catch (error) {
    logger.error(`Failed to clone plugin: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Clone plugin repository
 */
private async clonePlugin(
  parsed: ParsedPluginSource,
  targetPath: string,
  options?: PluginLoaderOptions
): Promise<void> {
  // Build clone command
  const args = ['clone', '--depth', '1'];

  // Add branch/tag if specified
  if (parsed.version) {
    args.push('--branch', parsed.version);
  }

  args.push('--single-branch');

  // Add token to URL if provided
  let cloneUrl = parsed.cloneUrl;
  if (options?.token) {
    const url = new URL(cloneUrl);
    url.username = options.token;
    url.password = 'x-oauth-basic';
    cloneUrl = url.toString();
  }

  args.push(cloneUrl, targetPath);

  const command = `git ${args.join(' ')}`;
  const timeout = options?.timeout ?? 5 * 60 * 1000;

  logger.debug(`Cloning plugin: ${parsed.owner}/${parsed.repo}${parsed.version ? `@${parsed.version}` : ''}`);

  // Create parent directory
  await fs.promises.mkdir(path.dirname(targetPath), { recursive: true });

  await execAsync(command, {
    timeout,
    env: {
      ...process.env,
      GIT_TERMINAL_PROMPT: '0',
    },
  });
}
```

### 5.3 Edge Cases to Handle

- [ ] Invalid source format → Return error in `LoadResult.errors`
- [ ] Missing owner or repo → Return parse error
- [ ] Network failure during clone → Return meaningful error
- [ ] Private repo without token → Return auth error hint
- [ ] Version tag doesn't exist → Return error with available versions hint
- [ ] Plugin has no plugin.json → Still load, delegate to claude-plugin conventions
- [ ] Subpath specified but doesn't exist → Return error after clone
- [ ] Cache directory not writable → Fall back to temp directory
- [ ] Git not installed → Return helpful error message

## 6. Test Requirements

### 6.1 Test Fixture

Create `tests/fixtures/plugins/test-plugin/`:

**plugin.json**:
```json
{
  "name": "test-plugin",
  "version": "1.0.0",
  "description": "Test plugin for unit tests"
}
```

**skills/test-skill/SKILL.md**:
```markdown
---
name: test-skill
description: Test skill
---

# Test Skill

This is a test skill.
```

### 6.2 Test File Structure

Create `tests/unit/loaders/plugin.test.ts`:

```typescript
describe('PluginLoader', () => {
  describe('canLoad()', () => {
    it('should return true for github: prefix', () => { /* ... */ });
    it('should return true for gitlab: prefix', () => { /* ... */ });
    it('should return true for bitbucket: prefix', () => { /* ... */ });
    it('should return true for plugin:github: prefix', () => { /* ... */ });
    it('should return false for other sources', () => { /* ... */ });
  });

  describe('parseSource()', () => {
    describe('github format', () => {
      it('should parse github:owner/repo', () => { /* ... */ });
      it('should parse github:owner/repo@v1.0.0', () => { /* ... */ });
      it('should parse github:owner/repo/subpath@v1.0.0', () => { /* ... */ });
    });

    describe('gitlab format', () => {
      it('should parse gitlab:owner/repo', () => { /* ... */ });
      it('should parse gitlab:owner/repo@1.0.0', () => { /* ... */ });
    });

    describe('plugin prefix', () => {
      it('should parse plugin:github:owner/repo', () => { /* ... */ });
    });

    describe('error cases', () => {
      it('should return null for invalid format', () => { /* ... */ });
      it('should return null for missing repo', () => { /* ... */ });
    });
  });

  describe('load() - with mocked git', () => {
    // Use vi.mock for git operations
    it('should clone and load plugin content', async () => { /* ... */ });
    it('should use cache on second load', async () => { /* ... */ });
    it('should force refresh when option set', async () => { /* ... */ });
    it('should handle clone failure gracefully', async () => { /* ... */ });
  });

  describe('load() - with local fixture', () => {
    // Test with file:// URL or direct path to fixture
    it('should load rules from cloned plugin', async () => { /* ... */ });
    it('should load personas from cloned plugin', async () => { /* ... */ });
  });
});
```

### 6.3 Required Test Cases

- [x] **canLoad detection**: All prefixes recognized

```typescript
it('should return true for all supported prefixes', () => {
  const loader = new PluginLoader();

  expect(loader.canLoad('github:owner/repo')).toBe(true);
  expect(loader.canLoad('gitlab:owner/repo')).toBe(true);
  expect(loader.canLoad('bitbucket:owner/repo')).toBe(true);
  expect(loader.canLoad('plugin:github:owner/repo')).toBe(true);
  
  expect(loader.canLoad('npm:package')).toBe(false);
  expect(loader.canLoad('./local/path')).toBe(false);
});
```

- [x] **Source parsing**: All formats parsed correctly

```typescript
it('should parse github:owner/repo@v1.0.0 correctly', () => {
  const loader = new PluginLoader();
  const parsed = loader.parseSource('github:owner/repo@v1.0.0');

  expect(parsed).not.toBeNull();
  expect(parsed!.host).toBe('github.com');
  expect(parsed!.owner).toBe('owner');
  expect(parsed!.repo).toBe('repo');
  expect(parsed!.version).toBe('v1.0.0');
  expect(parsed!.cloneUrl).toBe('https://github.com/owner/repo.git');
});

it('should parse github:owner/repo/skills@v1.0.0 with subpath', () => {
  const loader = new PluginLoader();
  const parsed = loader.parseSource('github:owner/repo/skills@v1.0.0');

  expect(parsed!.subpath).toBe('skills');
});
```

- [x] **Version in cache ID**: Different versions cached separately

```typescript
it('should generate different cache IDs for different versions', () => {
  const id1 = generatePluginId('github:owner/repo', 'v1.0.0');
  const id2 = generatePluginId('github:owner/repo', 'v2.0.0');
  const id3 = generatePluginId('github:owner/repo', undefined);

  expect(id1).not.toBe(id2);
  expect(id1).not.toBe(id3);
  expect(id1).toContain('v1.0.0');
  expect(id2).toContain('v2.0.0');
});
```

- [x] **Error handling**: Graceful failure

```typescript
it('should return error for invalid source format', async () => {
  const loader = new PluginLoader();
  const result = await loader.load('invalid:source');

  expect(result.rules.length).toBe(0);
  expect(result.errors).toBeDefined();
  expect(result.errors!.length).toBeGreaterThan(0);
  expect(result.errors![0].message).toContain('Invalid plugin source');
});
```

- [x] **Cache integration**: Uses plugin cache correctly

```typescript
it('should use cache on second load', async () => {
  const tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'plugin-test-'));
  const pluginCache = await createPluginCache(tempDir);
  
  // Mock git clone to track calls
  const cloneSpy = vi.fn();
  
  const loader = new PluginLoader();
  
  // First load - should clone
  await loader.load('github:test/repo@v1.0.0', {
    pluginCache: pluginCache.value,
    cacheDir: tempDir,
  });
  expect(cloneSpy).toHaveBeenCalledTimes(1);
  
  // Second load - should use cache
  await loader.load('github:test/repo@v1.0.0', {
    pluginCache: pluginCache.value,
    cacheDir: tempDir,
  });
  expect(cloneSpy).toHaveBeenCalledTimes(1); // Not called again
});
```

## 7. Integration Points

- **Imports from**: 
  - `src/loaders/base.ts` - `Loader`, `LoadResult`, `LoaderOptions`
  - `src/loaders/claude-plugin.ts` - `ClaudePluginLoader` (delegate content loading)
  - `src/utils/plugin-cache.ts` - `PluginCache`, `generatePluginId`, `createPluginCache`
- **Exports to**: 
  - `src/loaders/index.ts` - Export `PluginLoader`, `createPluginLoader`
  - Will be used by config loader when `plugins:` section is processed
- **Config**: Will integrate with `config.yaml` plugins section (T159)

## 8. Acceptance Criteria

- [x] `canLoad()` returns true for github:, gitlab:, bitbucket:, plugin: prefixes
- [x] `parseSource()` correctly extracts owner, repo, version, subpath
- [x] Plugins are cloned to `.ai-tool-sync/plugins/` directory
- [x] Different versions are cached separately
- [x] Cache is used on subsequent loads (no re-clone)
- [x] `forceRefresh` option bypasses cache
- [x] Content loading delegates to `ClaudePluginLoader`
- [x] Errors are returned gracefully, not thrown
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)
- [x] Exported from `src/loaders/index.ts`

## 9. Out of Scope

- `config.yaml` plugins section support (handled in T159)
- Plugin CLI commands (`ai-sync plugins add/remove`) (handled in T160)
- Plugin update mechanism (handled in T151)
- SSH authentication (HTTPS with token only for now)
- Semver range support (exact pins only, e.g., `@v1.0.0`, not `@^1.0.0`)
- Plugin marketplace registry/discovery

## 10. Implementation Checklist

1. [x] Read existing git loader code (`src/loaders/git.ts`)
2. [x] Read plugin cache code (`src/utils/plugin-cache.ts`)
3. [x] Create `src/loaders/plugin.ts` with `PluginLoader` class
4. [x] Implement `canLoad()` method with all prefix checks
5. [x] Implement `parseSource()` with all format support
6. [x] Implement `ensurePluginCloned()` with cache integration
7. [x] Implement `clonePlugin()` with shallow clone
8. [x] Implement `load()` that delegates to `ClaudePluginLoader`
9. [x] Export from `src/loaders/index.ts`
10. [x] Create test fixture at `tests/fixtures/plugins/test-plugin/`
11. [x] Create `tests/unit/loaders/plugin.test.ts` with mocked git
12. [x] Run `npm test -- plugin.test.ts` to verify
13. [x] Run `npm run lint` to verify no lint errors
14. [ ] Manual test with a real GitHub plugin (if available)

