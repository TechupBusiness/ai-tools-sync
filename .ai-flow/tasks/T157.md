# T157: Add Plugin MCP Server Extraction

> **Priority**: P2 | **Wave**: 2 | **Track**: A (Plugin Infrastructure)
> **Depends on**: T155
> **Estimated complexity**: Medium

## 1. Objective

Enhance the Claude plugin loader to extract MCP server configurations from `.mcp.json` files in Claude plugins. Claude plugins can bundle their own MCP servers (auto-lifecycle managed), which should be merged with the project's MCP configuration during sync. This enables ai-tool-sync to fully consume Claude Code plugins that provide MCP servers, making those servers available across all target platforms (Cursor, Claude, Factory).

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/parsers/mcp.ts` - **MCP config structure and parsing** (use same types)
- `src/loaders/claude-plugin.ts` lines 547-582 - **loadManifest pattern** to adapt for MCP
- `src/loaders/claude-plugin.ts` lines 20-21 - **Import resolvePluginRootVariable** already in place
- `src/loaders/base.ts` lines 14-35 - **LoadResult interface** (need to extend with MCP)
- `tests/unit/parsers/mcp.test.ts` - **Test patterns for MCP parsing**

## 3. File Structure

```
src/
├── loaders/
│   ├── base.ts               # Extend LoadResult with mcpServers
│   └── claude-plugin.ts      # Add loadMcpFromPath method
tests/
├── fixtures/
│   └── claude-plugins/
│       └── mcp-plugin/       # NEW: Test fixture with .mcp.json
│           ├── plugin.json
│           └── .mcp.json
└── unit/
    └── loaders/
        └── claude-plugin.test.ts   # Add MCP test cases
```

## 4. Interfaces & Types

Extend `LoadResult` to include MCP servers:

```typescript
// In src/loaders/base.ts - EXTEND LoadResult interface

import type { McpConfig, McpServer } from '../parsers/mcp.js';

/**
 * Result of loading content from a source
 */
export interface LoadResult {
  /** Parsed rules */
  rules: ParsedRule[];
  /** Parsed personas */
  personas: ParsedPersona[];
  /** Parsed commands */
  commands: ParsedCommand[];
  /** Parsed hooks */
  hooks: ParsedHook[];
  /** MCP servers from plugins (NEW) */
  mcpServers?: Record<string, McpServer>;
  /** Non-fatal errors encountered during loading */
  errors?: LoadError[];
  /** Source identifier */
  source?: string;
  /** Optional metadata from loader */
  metadata?: {
    pluginName?: string;
    pluginVersion?: string;
    pluginDescription?: string;
    [key: string]: unknown;
  };
}
```

Add Claude plugin MCP structure:

```typescript
// In src/loaders/claude-plugin.ts - ADD interface

/**
 * Claude plugin .mcp.json structure
 * Supports stdio, HTTP, and SSE transport types
 */
export interface ClaudePluginMcpJson {
  mcpServers?: Record<string, ClaudePluginMcpServer>;
}

export interface ClaudePluginMcpServer {
  /** Command for stdio transport */
  command?: string;
  /** Args for stdio transport */
  args?: string[];
  /** Environment variables */
  env?: Record<string, string>;
  /** Working directory */
  cwd?: string;
  /** URL for HTTP/SSE transport */
  url?: string;
  /** HTTP transport type */
  type?: 'http' | 'sse';
  /** HTTP headers for HTTP/SSE transport */
  headers?: Record<string, string>;
  /** Server description */
  description?: string;
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use `McpServer` types from `src/parsers/mcp.ts` for output
- [x] Use `resolvePluginRootVariable()` for path substitution
- [x] Use `interpolateEnvVars()` from `src/parsers/mcp.ts` for env var substitution
- [x] Return servers in `LoadResult.mcpServers` field
- [x] Handle both command-based (stdio) and URL-based (http/sse) servers
- [x] Log using `logger.debug()` for tracing

### 5.2 Critical Logic (Pitfall Prevention)

Add MCP loading to the main `load()` method:

```typescript
// In load() method, after loading hooks:

// Load MCP servers - from manifest path or convention (.mcp.json)
const mcpPath = manifest?.mcpServers ?? this.findMcpFile(pluginPath);
if (mcpPath) {
  const mcpResult = await this.loadMcpFromPath(mcpPath, pluginPath, options);
  if (Object.keys(mcpResult.servers).length > 0) {
    result.mcpServers = mcpResult.servers;
  }
  errors.push(...mcpResult.errors);
}
```

Add MCP file finder:

```typescript
/**
 * Find MCP configuration file using convention paths
 */
private findMcpFile(pluginPath: string): string | undefined {
  const candidates = [
    path.join(pluginPath, '.mcp.json'),
    path.join(pluginPath, 'mcp.json'),
  ];

  for (const candidate of candidates) {
    if (this.fileExists(candidate)) {
      return candidate;
    }
  }

  return undefined;
}
```

Implement MCP loading:

```typescript
/**
 * Load MCP server configurations from a plugin
 */
private async loadMcpFromPath(
  mcpPath: string,
  pluginRoot: string,
  _options?: ClaudePluginLoaderOptions
): Promise<{ servers: Record<string, McpServer>; errors: LoadError[] }> {
  const servers: Record<string, McpServer> = {};
  const errors: LoadError[] = [];

  if (!this.fileExists(mcpPath)) {
    return { servers, errors };
  }

  try {
    const content = await fs.promises.readFile(mcpPath, 'utf-8');
    
    // Resolve ${CLAUDE_PLUGIN_ROOT} first
    const resolvedContent = resolvePluginRootVariable(content, pluginRoot);
    
    // Then interpolate environment variables
    const interpolatedContent = interpolateEnvVars(resolvedContent);
    
    const parsed = JSON.parse(interpolatedContent) as ClaudePluginMcpJson;

    if (parsed.mcpServers) {
      for (const [name, serverConfig] of Object.entries(parsed.mcpServers)) {
        const transformed = this.transformMcpServer(serverConfig, name);
        if (transformed) {
          servers[name] = transformed;
        }
      }
    }

    logger.debug(`Loaded ${Object.keys(servers).length} MCP servers from plugin`);
  } catch (error) {
    errors.push({
      type: 'file',
      path: mcpPath,
      message: `Failed to parse MCP config: ${error instanceof Error ? error.message : String(error)}`,
    });
  }

  return { servers, errors };
}

/**
 * Transform Claude plugin MCP server to generic format
 */
private transformMcpServer(
  config: ClaudePluginMcpServer,
  name: string
): McpServer | null {
  // Command-based (stdio) server
  if (config.command) {
    const server: McpCommandServer = {
      command: config.command,
    };

    if (config.args && config.args.length > 0) {
      server.args = config.args;
    }
    if (config.env && Object.keys(config.env).length > 0) {
      server.env = config.env;
    }
    if (config.cwd) {
      server.cwd = config.cwd;
    }
    if (config.description) {
      server.description = config.description;
    }

    // Default to all targets (plugin servers should work everywhere)
    server.targets = ['cursor', 'claude', 'factory'];
    server.enabled = true;

    return server;
  }

  // URL-based (HTTP/SSE) server
  if (config.url) {
    const server: McpUrlServer = {
      url: config.url,
    };

    if (config.headers && Object.keys(config.headers).length > 0) {
      server.headers = config.headers;
    }
    if (config.description) {
      server.description = config.description;
    }

    server.targets = ['cursor', 'claude', 'factory'];
    server.enabled = true;

    return server;
  }

  logger.warn(`MCP server '${name}' has neither command nor url, skipping`);
  return null;
}
```

Update `emptyLoadResult` functions:

```typescript
// In src/loaders/base.ts

export function emptyLoadResult(): LoadResult {
  return {
    rules: [],
    personas: [],
    commands: [],
    hooks: [],
    // Note: mcpServers is optional, don't include if empty
  };
}

// Update mergeLoadResults to merge MCP servers
export function mergeLoadResults(...results: LoadResult[]): LoadResult {
  const errors: LoadError[] = [];
  let mcpServers: Record<string, McpServer> | undefined;

  for (const r of results) {
    if (r.errors && r.errors.length > 0) {
      errors.push(...r.errors);
    }
    
    // Merge MCP servers (later results override earlier ones with same name)
    if (r.mcpServers) {
      mcpServers = { ...mcpServers, ...r.mcpServers };
    }
  }

  const merged: LoadResult = {
    rules: results.flatMap((r) => r.rules),
    personas: results.flatMap((r) => r.personas),
    commands: results.flatMap((r) => r.commands),
    hooks: results.flatMap((r) => r.hooks),
  };

  if (mcpServers && Object.keys(mcpServers).length > 0) {
    merged.mcpServers = mcpServers;
  }

  if (errors.length > 0) {
    merged.errors = errors;
  }

  return merged;
}
```

### 5.3 Edge Cases to Handle

- [ ] Empty `.mcp.json` `{}` → Return empty servers object
- [ ] Empty `mcpServers` field → Return empty servers object
- [ ] Server with neither `command` nor `url` → Log warning, skip server
- [ ] Server with both `command` and `url` → Prefer `command` (stdio)
- [ ] `${CLAUDE_PLUGIN_ROOT}` in command/args/cwd → Resolve before storing
- [ ] `${ENV_VAR}` in env values/headers → Interpolate from process.env
- [ ] Invalid JSON → Return error, don't fail entire plugin load
- [ ] Missing `.mcp.json` → No error, just no servers returned

## 6. Test Requirements

### 6.1 Test Fixture

Create `tests/fixtures/claude-plugins/mcp-plugin/`:

**plugin.json**:
```json
{
  "name": "mcp-test-plugin",
  "version": "1.0.0",
  "description": "Plugin with MCP servers",
  "mcpServers": ".mcp.json"
}
```

**.mcp.json**:
```json
{
  "mcpServers": {
    "local-server": {
      "command": "node",
      "args": ["${CLAUDE_PLUGIN_ROOT}/mcp-server/index.js"],
      "env": {
        "DEBUG": "true",
        "API_KEY": "${MCP_API_KEY}"
      },
      "cwd": "${CLAUDE_PLUGIN_ROOT}",
      "description": "Local MCP server bundled with plugin"
    },
    "remote-api": {
      "type": "http",
      "url": "https://api.example.com/mcp",
      "headers": {
        "Authorization": "Bearer ${API_TOKEN}",
        "X-Custom-Header": "value"
      },
      "description": "Remote HTTP MCP server"
    },
    "sse-server": {
      "type": "sse",
      "url": "https://api.example.com/mcp/sse",
      "description": "SSE-based MCP server"
    }
  }
}
```

Create dummy file structure:
```
mcp-plugin/
├── plugin.json
├── .mcp.json
└── mcp-server/
    └── index.js  # Empty placeholder
```

### 6.2 Test File Structure

Add to `tests/unit/loaders/claude-plugin.test.ts`:

```typescript
describe('load() - MCP servers from .mcp.json', () => {
  const mcpPluginPath = path.join(FIXTURES_PATH, 'mcp-plugin');

  describe('server loading', () => {
    it('should load MCP servers from .mcp.json', async () => { /* ... */ });
    it('should load both stdio and HTTP servers', async () => { /* ... */ });
    it('should load SSE servers', async () => { /* ... */ });
  });

  describe('variable substitution', () => {
    it('should resolve ${CLAUDE_PLUGIN_ROOT} in paths', async () => { /* ... */ });
    it('should interpolate ${ENV_VAR} in env values', async () => { /* ... */ });
    it('should interpolate ${ENV_VAR} in headers', async () => { /* ... */ });
  });

  describe('error handling', () => {
    it('should skip servers without command or url', async () => { /* ... */ });
    it('should handle missing .mcp.json gracefully', async () => { /* ... */ });
  });

  describe('target assignment', () => {
    it('should assign all targets to plugin MCP servers', async () => { /* ... */ });
  });
});
```

### 6.3 Required Test Cases

- [ ] **Basic loading**: Load all server types

```typescript
it('should load MCP servers from .mcp.json', async () => {
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  expect(result.mcpServers).toBeDefined();
  expect(Object.keys(result.mcpServers!).length).toBe(3);
  expect(result.mcpServers!['local-server']).toBeDefined();
  expect(result.mcpServers!['remote-api']).toBeDefined();
  expect(result.mcpServers!['sse-server']).toBeDefined();
});
```

- [ ] **Stdio server**: Command-based server loaded correctly

```typescript
it('should load stdio (command) servers correctly', async () => {
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  const server = result.mcpServers!['local-server'];
  expect(server).toBeDefined();
  expect('command' in server).toBe(true);
  expect((server as McpCommandServer).command).toBe('node');
  expect((server as McpCommandServer).args).toContain(
    expect.stringContaining('mcp-server/index.js')
  );
  expect(server.description).toBe('Local MCP server bundled with plugin');
});
```

- [ ] **HTTP server**: URL-based server loaded correctly

```typescript
it('should load HTTP servers correctly', async () => {
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  const server = result.mcpServers!['remote-api'];
  expect(server).toBeDefined();
  expect('url' in server).toBe(true);
  expect((server as McpUrlServer).url).toBe('https://api.example.com/mcp');
  expect((server as McpUrlServer).headers).toBeDefined();
  expect((server as McpUrlServer).headers!['X-Custom-Header']).toBe('value');
});
```

- [ ] **Plugin root resolution**: Paths resolved

```typescript
it('should resolve ${CLAUDE_PLUGIN_ROOT} in server paths', async () => {
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  const server = result.mcpServers!['local-server'] as McpCommandServer;
  
  // Args should contain resolved absolute path
  expect(server.args![0]).not.toContain('${CLAUDE_PLUGIN_ROOT}');
  expect(server.args![0]).toContain(mcpPluginPath);
  
  // cwd should be resolved
  expect(server.cwd).not.toContain('${CLAUDE_PLUGIN_ROOT}');
  expect(server.cwd).toContain(mcpPluginPath);
});
```

- [ ] **Env interpolation**: Environment variables interpolated

```typescript
it('should interpolate environment variables', async () => {
  // Set up test env var
  process.env.MCP_API_KEY = 'test-key-12345';
  
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  const server = result.mcpServers!['local-server'] as McpCommandServer;
  expect(server.env!['API_KEY']).toBe('test-key-12345');
  
  // Clean up
  delete process.env.MCP_API_KEY;
});
```

- [ ] **Target assignment**: All targets assigned

```typescript
it('should assign all targets to plugin MCP servers', async () => {
  const result = await loader.load(`claude-plugin:${mcpPluginPath}`);

  for (const server of Object.values(result.mcpServers!)) {
    expect(server.targets).toEqual(['cursor', 'claude', 'factory']);
    expect(server.enabled).toBe(true);
  }
});
```

## 7. Integration Points

- **Imports from**: 
  - `src/parsers/mcp.ts` - use `McpServer`, `McpCommandServer`, `McpUrlServer`, `interpolateEnvVars`
  - `src/utils/plugin-cache.ts` - use `resolvePluginRootVariable()`
- **Exports to**: 
  - `LoadResult.mcpServers` used by generators to merge with project MCP config
- **Config**: No config schema changes needed

## 8. Acceptance Criteria

- [x] All existing claude-plugin loader tests pass
- [x] New MCP loading tests pass
- [x] Stdio (command) servers are extracted correctly
- [x] HTTP/SSE (url) servers are extracted correctly
- [x] `${CLAUDE_PLUGIN_ROOT}` is resolved in all path fields
- [x] `${ENV_VAR}` is interpolated in env and headers
- [x] `LoadResult.mcpServers` is populated correctly
- [x] `mergeLoadResults` correctly merges MCP servers
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)

## 9. Out of Scope

- MCP server execution or lifecycle management
- MCP server validation (just pass through the config)
- MCP server authentication beyond header substitution
- Generator updates to merge plugin MCP with project MCP (separate task if needed)
- Websocket transport (not in Claude plugin spec)

## 10. Implementation Checklist

1. [x] Read MCP parser code (`src/parsers/mcp.ts`)
2. [x] Extend `LoadResult` in `src/loaders/base.ts` with `mcpServers` field
3. [x] Update `emptyLoadResult` and `mergeLoadResults` helper functions
4. [x] Add `ClaudePluginMcpJson` and `ClaudePluginMcpServer` interfaces
5. [x] Add `findMcpFile` method to claude-plugin loader
6. [x] Add `loadMcpFromPath` method with variable substitution
7. [x] Add `transformMcpServer` method for format conversion
8. [x] Update main `load()` method to call MCP loading
9. [x] Create test fixture at `tests/fixtures/claude-plugins/mcp-plugin/`
10. [x] Write test cases in `tests/unit/loaders/claude-plugin.test.ts`
11. [x] Run `npm test -- claude-plugin.test.ts` to verify
12. [x] Run `npm test -- base.test.ts` to verify LoadResult changes don't break anything (test file not present)
13. [x] Run `npm run lint` to verify no lint errors

