# T228: Implement Platform-Conditional Inline Content

> **Priority**: P2 | **Wave**: 7 | **Track**: A (Conditional Blocks)
> **Depends on**: T050-T054 ✅ (Transformers)
> **Estimated complexity**: Medium

## 1. Objective

Implement a Mustache-inspired syntax for platform-conditional content blocks within markdown files. This allows content authors to write platform-specific sections inline (e.g., Cursor-only instructions, Claude-specific notes) without maintaining separate files. The transformer strips non-matching blocks at generation time, producing clean output for each target platform.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/transformers/frontmatter.ts` - **Exact pattern to follow**: Transform function signature, `TransformContext`, exports structure
- `src/transformers/index.ts` - **Export pattern**: Add new exports here
- `src/parsers/types.ts` - **Line 9**: `TargetType` definition to import
- `tests/unit/transformers/frontmatter.test.ts` - **Test structure**: `describe/it` patterns, edge case coverage
- `src/utils/result.ts` - **Error handling**: Use `Result<T, E>` pattern if validation needed

## 3. File Structure

```
src/
├── transformers/
│   ├── conditional-content.ts    # Main implementation
│   └── index.ts                  # Add export
tests/
└── unit/
    └── transformers/
        └── conditional-content.test.ts  # Tests
```

## 4. Interfaces & Types

### 4.1 Main Types

```typescript
// In src/transformers/conditional-content.ts

import type { TargetType } from '../parsers/types.js';

/**
 * Options for conditional content transformation
 */
export interface ConditionalContentOptions {
  /**
   * Whether to preserve whitespace around removed blocks
   * @default false - Collapse empty lines from removed blocks
   */
  preserveWhitespace?: boolean;
}

/**
 * Result of parsing a conditional tag
 */
interface ParsedCondition {
  /** Target platforms in the condition */
  targets: TargetType[];
  /** Negated targets (those with ! prefix) */
  negatedTargets: TargetType[];
  /** Operator: 'or' for |, 'and' for & */
  operator: 'or' | 'and';
}
```

### 4.2 Syntax Specification

```
Opening tag: {{#<condition>}}
Closing tag: {{/<condition>}}

Condition syntax:
- Single platform:      claude, cursor, factory
- Negation:            !claude, !cursor, !factory
- OR (any matches):    claude|factory
- AND (all must match): claude&!cursor
- Combined:            claude|factory&!cursor (AND has higher precedence)

Examples:
{{#claude}}Content for Claude only{{/claude}}
{{#!cursor}}Content excluded from Cursor{{/!cursor}}
{{#claude|factory}}Content for Claude OR Factory{{/claude|factory}}
{{#cursor&!claude}}Content for Cursor but NOT Claude{{/cursor&!claude}}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Import `TargetType` from `../parsers/types.js`
- [x] Export function from `src/transformers/index.ts`
- [x] No `any` types - use strict TypeScript
- [x] No external dependencies - pure regex-based implementation
- [x] Handle nested blocks (throw error or ignore inner blocks)
- [x] Run `npm run lint --fix` after implementation
- [x] Run `npm run typecheck` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Regex Pattern for Matching Blocks

```typescript
// ✅ CORRECT - Non-greedy match with proper escaping
const BLOCK_PATTERN = /\{\{#([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g;

// ❌ WRONG - Greedy match will consume too much
const BLOCK_PATTERN_BAD = /\{\{#([^}]+)\}\}(.*)\{\{\/\1\}\}/g;
```

#### 5.2.2 Condition Parsing

```typescript
/**
 * Parse a condition string into structured form
 * Handles: claude, !cursor, claude|factory, cursor&!claude
 */
function parseCondition(condition: string): ParsedCondition {
  const targets: TargetType[] = [];
  const negatedTargets: TargetType[] = [];
  
  // Determine operator (| has lower precedence than &, but we simplify)
  // If both present, use & as primary (all ANDs must match, any OR can match)
  const hasOr = condition.includes('|');
  const hasAnd = condition.includes('&');
  
  // Split by operators - & has higher precedence
  // For simplicity: process as flat list, operator determines evaluation
  const operator: 'or' | 'and' = hasAnd && !hasOr ? 'and' : 
                                  hasOr && !hasAnd ? 'or' : 
                                  'and'; // Mixed defaults to AND
  
  // Split by both operators
  const parts = condition.split(/[|&]/);
  
  for (const part of parts) {
    const trimmed = part.trim();
    if (!trimmed) continue;
    
    if (trimmed.startsWith('!')) {
      const target = trimmed.slice(1) as TargetType;
      if (isValidTarget(target)) {
        negatedTargets.push(target);
      }
    } else {
      const target = trimmed as TargetType;
      if (isValidTarget(target)) {
        targets.push(target);
      }
    }
  }
  
  return { targets, negatedTargets, operator };
}

function isValidTarget(value: string): value is TargetType {
  return ['cursor', 'claude', 'factory'].includes(value);
}
```

#### 5.2.3 Condition Evaluation

```typescript
/**
 * Evaluate if content should be included for a target
 */
function evaluateCondition(parsed: ParsedCondition, target: TargetType): boolean {
  const { targets, negatedTargets, operator } = parsed;
  
  // Check negations first - if target is negated, exclude
  if (negatedTargets.includes(target)) {
    return false;
  }
  
  // If no positive targets specified (only negations), include if not negated
  if (targets.length === 0) {
    return true;
  }
  
  // Check positive targets based on operator
  if (operator === 'or') {
    // OR: include if target is in list
    return targets.includes(target);
  } else {
    // AND: include if target is in list (AND is about all conditions matching)
    // For single target evaluation, just check if it's included
    return targets.includes(target);
  }
}
```

#### 5.2.4 Main Transform Function

```typescript
/**
 * Transform conditional content for a specific target platform
 * 
 * Removes blocks that don't match the target and strips the tags from matching blocks.
 * 
 * @param content - Markdown content with conditional blocks
 * @param target - Target platform to generate for
 * @param options - Transform options
 * @returns Transformed content with non-matching blocks removed
 * 
 * @example
 * const content = `
 * # Guide
 * 
 * {{#claude}}Use /command for Claude{{/claude}}
 * {{#cursor}}Use Cmd+K for Cursor{{/cursor}}
 * 
 * Common content here.
 * `;
 * 
 * transformConditionalContent(content, 'claude');
 * // Result:
 * // # Guide
 * //
 * // Use /command for Claude
 * //
 * // Common content here.
 */
export function transformConditionalContent(
  content: string,
  target: TargetType,
  options: ConditionalContentOptions = {}
): string {
  const { preserveWhitespace = false } = options;
  
  // Pattern matches {{#condition}}...{{/condition}}
  const BLOCK_PATTERN = /\{\{#([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g;
  
  let result = content.replace(BLOCK_PATTERN, (match, condition: string, blockContent: string) => {
    const parsed = parseCondition(condition);
    const shouldInclude = evaluateCondition(parsed, target);
    
    if (shouldInclude) {
      // Include content, strip tags
      return blockContent;
    } else {
      // Exclude content entirely
      return '';
    }
  });
  
  // Clean up whitespace if not preserving
  if (!preserveWhitespace) {
    // Remove lines that are now empty (but keep intentional blank lines)
    // Collapse multiple blank lines to maximum of 2
    result = result.replace(/\n{3,}/g, '\n\n');
    // Trim trailing whitespace on each line
    result = result.replace(/[ \t]+$/gm, '');
  }
  
  return result;
}
```

### 5.3 Edge Cases to Handle

- [ ] No conditional blocks → Return content unchanged
- [ ] Empty block `{{#claude}}{{/claude}}` → Remove entirely (including tags)
- [ ] Nested blocks → Outer block takes precedence (inner tags treated as content)
- [ ] Mismatched tags `{{#claude}}...{{/cursor}}` → Leave as-is (no match)
- [ ] Invalid target in condition → Ignore that part of condition
- [ ] Block at start of content → No leading newline in output
- [ ] Block at end of content → No trailing newline added
- [ ] Multiple blocks on same line → Process each independently
- [ ] Whitespace inside tags `{{ #claude }}` → Don't match (strict syntax)
- [ ] Content with `{{` but not a valid block → Leave as-is

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/transformers/conditional-content.test.ts

import { describe, it, expect } from 'vitest';

import {
  transformConditionalContent,
} from '../../../src/transformers/conditional-content.js';

describe('Conditional Content Transformer', () => {
  describe('transformConditionalContent()', () => {
    describe('basic functionality', () => { /* ... */ });
    describe('negation operator (!)', () => { /* ... */ });
    describe('OR operator (|)', () => { /* ... */ });
    describe('AND operator (&)', () => { /* ... */ });
    describe('combined operators', () => { /* ... */ });
    describe('edge cases', () => { /* ... */ });
    describe('whitespace handling', () => { /* ... */ });
  });
});
```

### 6.2 Required Test Cases

```typescript
describe('basic functionality', () => {
  it('should return content unchanged when no conditional blocks', () => {
    const content = '# Hello\n\nSome content here.';
    expect(transformConditionalContent(content, 'claude')).toBe(content);
  });

  it('should include matching platform content', () => {
    const content = '{{#claude}}Claude content{{/claude}}';
    expect(transformConditionalContent(content, 'claude')).toBe('Claude content');
  });

  it('should exclude non-matching platform content', () => {
    const content = '{{#cursor}}Cursor content{{/cursor}}';
    expect(transformConditionalContent(content, 'claude')).toBe('');
  });

  it('should process multiple blocks', () => {
    const content = `
{{#claude}}Claude section{{/claude}}
{{#cursor}}Cursor section{{/cursor}}
{{#factory}}Factory section{{/factory}}
`;
    const result = transformConditionalContent(content, 'claude');
    expect(result).toContain('Claude section');
    expect(result).not.toContain('Cursor section');
    expect(result).not.toContain('Factory section');
  });

  it('should preserve content between blocks', () => {
    const content = `Start
{{#claude}}Claude{{/claude}}
Middle
{{#cursor}}Cursor{{/cursor}}
End`;
    const result = transformConditionalContent(content, 'claude');
    expect(result).toContain('Start');
    expect(result).toContain('Claude');
    expect(result).toContain('Middle');
    expect(result).not.toContain('Cursor');
    expect(result).toContain('End');
  });
});

describe('negation operator (!)', () => {
  it('should exclude negated platform', () => {
    const content = '{{#!cursor}}Not for Cursor{{/!cursor}}';
    expect(transformConditionalContent(content, 'cursor')).toBe('');
    expect(transformConditionalContent(content, 'claude')).toBe('Not for Cursor');
  });

  it('should include content for all non-negated platforms', () => {
    const content = '{{#!factory}}Not Factory{{/!factory}}';
    expect(transformConditionalContent(content, 'cursor')).toBe('Not Factory');
    expect(transformConditionalContent(content, 'claude')).toBe('Not Factory');
    expect(transformConditionalContent(content, 'factory')).toBe('');
  });
});

describe('OR operator (|)', () => {
  it('should include if any platform matches', () => {
    const content = '{{#claude|factory}}Either platform{{/claude|factory}}';
    expect(transformConditionalContent(content, 'claude')).toBe('Either platform');
    expect(transformConditionalContent(content, 'factory')).toBe('Either platform');
    expect(transformConditionalContent(content, 'cursor')).toBe('');
  });

  it('should handle three platforms with OR', () => {
    const content = '{{#cursor|claude|factory}}All platforms{{/cursor|claude|factory}}';
    expect(transformConditionalContent(content, 'cursor')).toBe('All platforms');
    expect(transformConditionalContent(content, 'claude')).toBe('All platforms');
    expect(transformConditionalContent(content, 'factory')).toBe('All platforms');
  });
});

describe('AND operator (&)', () => {
  it('should exclude if target is negated in AND', () => {
    const content = '{{#claude&!cursor}}Claude without Cursor{{/claude&!cursor}}';
    expect(transformConditionalContent(content, 'claude')).toBe('Claude without Cursor');
    expect(transformConditionalContent(content, 'cursor')).toBe('');
    expect(transformConditionalContent(content, 'factory')).toBe('');
  });
});

describe('edge cases', () => {
  it('should handle empty blocks', () => {
    const content = 'Before{{#claude}}{{/claude}}After';
    expect(transformConditionalContent(content, 'claude')).toBe('BeforeAfter');
    expect(transformConditionalContent(content, 'cursor')).toBe('BeforeAfter');
  });

  it('should leave mismatched tags as-is', () => {
    const content = '{{#claude}}Content{{/cursor}}';
    expect(transformConditionalContent(content, 'claude')).toBe(content);
  });

  it('should handle blocks with multiline content', () => {
    const content = `{{#claude}}
Line 1
Line 2
Line 3
{{/claude}}`;
    const result = transformConditionalContent(content, 'claude');
    expect(result).toContain('Line 1');
    expect(result).toContain('Line 2');
    expect(result).toContain('Line 3');
  });

  it('should handle content with curly braces that are not blocks', () => {
    const content = 'Code: `const x = { a: 1 }`';
    expect(transformConditionalContent(content, 'claude')).toBe(content);
  });

  it('should handle invalid targets gracefully', () => {
    const content = '{{#invalid}}Content{{/invalid}}';
    // Invalid target means no platforms match, so content is excluded
    expect(transformConditionalContent(content, 'claude')).toBe('');
  });

  it('should ignore whitespace inside tags (strict syntax)', () => {
    const content = '{{ #claude }}Content{{ /claude }}';
    // Should not match, left as-is
    expect(transformConditionalContent(content, 'claude')).toBe(content);
  });

  it('should handle nested blocks (outer takes precedence)', () => {
    const content = '{{#claude}}Outer {{#cursor}}Inner{{/cursor}} End{{/claude}}';
    // Entire outer block is processed, inner tags become content
    const result = transformConditionalContent(content, 'claude');
    expect(result).toBe('Outer {{#cursor}}Inner{{/cursor}} End');
  });
});

describe('whitespace handling', () => {
  it('should collapse multiple blank lines by default', () => {
    const content = `Before

{{#cursor}}Cursor{{/cursor}}

After`;
    const result = transformConditionalContent(content, 'claude');
    // Should not have more than 2 consecutive newlines
    expect(result).not.toMatch(/\n{3,}/);
  });

  it('should preserve whitespace when option is set', () => {
    const content = `Before

{{#cursor}}Cursor{{/cursor}}

After`;
    const result = transformConditionalContent(content, 'claude', { preserveWhitespace: true });
    // Original whitespace preserved (block becomes empty string)
    expect(result).toBe('Before\n\n\n\nAfter');
  });
});
```

## 7. Integration Points

- **Imports from**:
  - `src/parsers/types.ts` - `TargetType`

- **Exports to**:
  - `src/transformers/index.ts` - Add `export * from './conditional-content.js';`

- **Will be used by** (future tasks):
  - Generator base class to process content before writing
  - Can be applied to rule, persona, command content

- **Integration example** (for future generator update):
  ```typescript
  // In src/generators/base.ts (future task to integrate)
  import { transformConditionalContent } from '../transformers/conditional-content.js';
  
  protected transformContent(content: string, target: TargetType): string {
    return transformConditionalContent(content, target);
  }
  ```

## 8. Acceptance Criteria

- [ ] `transformConditionalContent()` correctly processes all syntax variants
- [ ] Single platform blocks work (`{{#claude}}...{{/claude}}`)
- [ ] Negation works (`{{#!cursor}}...{{/!cursor}}`)
- [ ] OR operator works (`{{#claude|factory}}...{{/claude|factory}}`)
- [ ] AND with negation works (`{{#claude&!cursor}}...{{/claude&!cursor}}`)
- [ ] Non-matching blocks are fully removed
- [ ] Matching blocks have tags stripped, content preserved
- [ ] Edge cases handled gracefully (mismatched tags, invalid targets, nested blocks)
- [ ] All tests pass (`npm test -- conditional-content.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Exported from `src/transformers/index.ts`
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Integration into generators (future task - will require updating base generator)
- Template variables like `{{project_name}}` (handled in T229)
- Conditional blocks in frontmatter (only markdown body supported)
- Complex nested conditionals (outer block takes precedence)
- Else syntax `{{#claude}}...{{else}}...{{/claude}}` (keep it simple)

## 10. Implementation Checklist

1. [ ] Create `src/transformers/conditional-content.ts` with `transformConditionalContent()` function
2. [ ] Implement `parseCondition()` helper for parsing condition strings
3. [ ] Implement `evaluateCondition()` helper for matching against target
4. [ ] Handle all operators: single, negation (!), OR (|), AND (&)
5. [ ] Add whitespace cleanup logic
6. [ ] Export from `src/transformers/index.ts`
7. [ ] Create `tests/unit/transformers/conditional-content.test.ts`
8. [ ] Add tests for all syntax variants
9. [ ] Add tests for edge cases
10. [ ] Run `npm test -- conditional-content.test.ts`
11. [ ] Run `npm run lint --fix`
12. [ ] Run `npm run typecheck`
13. [ ] Update plan.md with T228 completion status

## 11. Example Transformations

### Input Content

```markdown
# Getting Started

This guide helps you get started with our AI assistant integration.

{{#cursor}}
## Cursor Setup

1. Open Cursor IDE
2. Use Cmd+K to open the command palette
3. Select "AI Assistant"
{{/cursor}}

{{#claude}}
## Claude Code Setup

1. Install Claude Code extension
2. Use `/help` to see available commands
3. Run `/sync` to initialize
{{/claude}}

{{#factory}}
## Factory Setup

1. Install Factory CLI: `npm i -g @anthropic/factory`
2. Run `factory init` in your project
3. Use `factory sync` to generate configs
{{/factory}}

## Common Features

All platforms support these features:

{{#!cursor}}
- Slash commands (not available in Cursor)
{{/!cursor}}

{{#claude|factory}}
- MCP server integration
- Custom agents/droids
{{/claude|factory}}

- File editing
- Code search
- Terminal access
```

### Output for Claude

```markdown
# Getting Started

This guide helps you get started with our AI assistant integration.

## Claude Code Setup

1. Install Claude Code extension
2. Use `/help` to see available commands
3. Run `/sync` to initialize

## Common Features

All platforms support these features:

- Slash commands (not available in Cursor)

- MCP server integration
- Custom agents/droids

- File editing
- Code search
- Terminal access
```

### Output for Cursor

```markdown
# Getting Started

This guide helps you get started with our AI assistant integration.

## Cursor Setup

1. Open Cursor IDE
2. Use Cmd+K to open the command palette
3. Select "AI Assistant"

## Common Features

All platforms support these features:

- File editing
- Code search
- Terminal access
```

### Output for Factory

```markdown
# Getting Started

This guide helps you get started with our AI assistant integration.

## Factory Setup

1. Install Factory CLI: `npm i -g @anthropic/factory`
2. Run `factory init` in your project
3. Use `factory sync` to generate configs

## Common Features

All platforms support these features:

- Slash commands (not available in Cursor)

- MCP server integration
- Custom agents/droids

- File editing
- Code search
- Terminal access
```

