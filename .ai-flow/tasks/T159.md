# T159: Add Marketplace Plugin Configuration Support

> **Priority**: P2 | **Wave**: 3 | **Track**: A (Plugin System)
> **Depends on**: T158 (Git-based plugin loader)
> **Estimated complexity**: Medium

## 1. Objective

Enable users to define plugins in `config.yaml` using the marketplace-style configuration syntax, allowing centralized management of Git-based plugins with source URLs, version pinning, and content filtering. This is the user-facing configuration layer that leverages the Git loader (T158) and plugin cache (T150) infrastructure.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:

- `src/config/types.ts` - `PluginConfig` interface already exists (lines 7-16), use as base
- `src/loaders/git.ts` - Pattern for parsing Git URLs with version refs
- `src/utils/plugin-cache.ts` - `generatePluginId()` and `PluginCache` class for caching
- `src/loaders/claude-plugin.ts` - Pattern for loading and transforming plugin content
- `src/config/loader.ts` - Configuration loading patterns

## 3. File Structure

```
src/
├── loaders/
│   ├── plugin.ts           # NEW: Plugin loader (orchestrates git + claude-plugin)
│   └── index.ts            # Add plugin loader export
├── config/
│   └── types.ts            # Extend PluginConfig if needed
tests/
└── unit/
    └── loaders/
        └── plugin.test.ts  # NEW: Plugin loader tests
```

## 4. Interfaces & Types

The `PluginConfig` interface already exists in `src/config/types.ts`. Extend/use as-is:

```typescript
// Already in types.ts - verify it matches this:
export interface PluginConfig {
  name: string;
  source: string;           // github:owner/repo@v1.0.0, gitlab:..., ./local
  version?: string;         // Explicit version (overrides source ref)
  enabled: boolean;
  include?: string[];       // ['rules', 'personas'] - filter content types
  exclude?: string[];       // ['commands'] - exclude content types
}

// NEW: Plugin loader options
export interface PluginLoaderOptions extends LoaderOptions {
  /**
   * Plugin cache instance (for version-aware caching)
   */
  pluginCache?: PluginCache;

  /**
   * Plugin configuration from config.yaml
   */
  config?: PluginConfig;

  /**
   * Whether to force refresh (ignore cache)
   */
  forceRefresh?: boolean;
}

// NEW: Plugin loader result with metadata
export interface PluginLoadResult extends LoadResult {
  /** Plugin metadata from manifest or source */
  pluginInfo?: {
    name: string;
    version?: string;
    source: string;
    description?: string;
  };
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use `Result<T, E>` for errors (see `src/utils/result.ts`)
- [x] Implement `Loader` interface from `src/loaders/base.ts`
- [x] Use `logger` for debug output (see `src/utils/logger.js`)
- [x] Export only from `src/loaders/index.ts`
- [x] Handle both local (`./path`) and Git (`github:owner/repo`) sources

### 5.2 Core Implementation: `PluginLoader` Class

```typescript
/**
 * Plugin Loader
 * 
 * Orchestrates plugin loading from config.yaml's `use.plugins` section.
 * Delegates to GitLoader for remote sources, LocalLoader for local paths,
 * then wraps with ClaudePluginLoader for content transformation.
 */
export class PluginLoader implements Loader {
  readonly name = 'plugin';

  private gitLoader: GitLoader;
  private localLoader: LocalLoader;
  private claudePluginLoader: ClaudePluginLoader;

  /**
   * Check if this loader can handle the given source
   * Handles: github:, gitlab:, bitbucket:, git:, and local paths
   */
  canLoad(source: string): boolean {
    // Delegate to git loader for remote sources
    if (this.gitLoader.canLoad(source)) {
      return true;
    }
    // Local plugin paths
    if (source.startsWith('./') || source.startsWith('../') || source.startsWith('/')) {
      return true;
    }
    return false;
  }

  /**
   * Load plugin content based on PluginConfig
   * 
   * Flow:
   * 1. Determine source type (git vs local)
   * 2. For git: use GitLoader to clone/cache
   * 3. Wrap with ClaudePluginLoader for content transformation
   * 4. Apply include/exclude filters from config
   * 5. Return filtered LoadResult
   */
  async load(source: string, options?: PluginLoaderOptions): Promise<PluginLoadResult>;
}
```

### 5.3 Critical Logic (Pitfall Prevention)

#### Version Resolution Priority

```typescript
// ❌ WRONG - Version in source URL ignored when config.version is set
const version = parsed.ref;

// ✅ CORRECT - Config version takes precedence
const version = options?.config?.version ?? extractVersionFromSource(source);
```

#### Content Type Filtering

```typescript
// ❌ WRONG - Filter applies after errors collected
if (config.include) {
  result.rules = config.include.includes('rules') ? result.rules : [];
}

// ✅ CORRECT - Filter before returning, preserve errors for unfiltered types
function filterResultByConfig(result: LoadResult, config: PluginConfig): LoadResult {
  const filtered = { ...result };
  
  if (config.include && config.include.length > 0) {
    filtered.rules = config.include.includes('rules') ? result.rules : [];
    filtered.personas = config.include.includes('personas') ? result.personas : [];
    filtered.commands = config.include.includes('commands') ? result.commands : [];
    filtered.hooks = config.include.includes('hooks') ? result.hooks : [];
  }
  
  if (config.exclude) {
    if (config.exclude.includes('rules')) filtered.rules = [];
    if (config.exclude.includes('personas')) filtered.personas = [];
    if (config.exclude.includes('commands')) filtered.commands = [];
    if (config.exclude.includes('hooks')) filtered.hooks = [];
  }
  
  return filtered;
}
```

#### Enabled Flag Check

```typescript
// ❌ WRONG - Load disabled plugins
async load(source: string, options?: PluginLoaderOptions): Promise<PluginLoadResult> {
  const result = await this.actuallyLoad(source);
  // ...
}

// ✅ CORRECT - Skip disabled plugins early
async load(source: string, options?: PluginLoaderOptions): Promise<PluginLoadResult> {
  if (options?.config?.enabled === false) {
    return emptyLoadResultWithSource(source);
  }
  // ...
}
```

### 5.4 Edge Cases to Handle

- [x] Disabled plugin (`enabled: false`) → Return `emptyLoadResultWithSource(source)`
- [x] Invalid source format → Return `Result.err()` with descriptive message
- [x] Version mismatch (cached vs requested) → Invalidate cache, re-fetch
- [x] Empty `include` array → Load nothing (all types filtered out)
- [x] Both `include` and `exclude` specified → Apply `include` first, then `exclude`
- [x] Local path not found → Return error with full resolved path
- [x] Git clone failure → Return error, preserve any cached version
- [x] Plugin without plugin.json → Still load content (manifest optional)

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/loaders/plugin.test.ts
describe('PluginLoader', () => {
  describe('canLoad()', () => {
    // Source format recognition
  });

  describe('load()', () => {
    describe('git sources', () => {
      // Remote plugin loading
    });

    describe('local sources', () => {
      // Local plugin loading
    });

    describe('filtering', () => {
      // include/exclude behavior
    });

    describe('enabled flag', () => {
      // Skip disabled plugins
    });

    describe('version handling', () => {
      // Config version vs source version
    });

    describe('error handling', () => {
      // Invalid sources, missing paths
    });
  });
});
```

### 6.2 Required Test Cases

- [x] `canLoad()` returns true for `github:owner/repo`
- [x] `canLoad()` returns true for `gitlab:owner/repo@v1.0.0`
- [x] `canLoad()` returns true for `./local/plugin`
- [x] `canLoad()` returns false for `npm:package` (not a plugin source)
- [x] Load plugin from local path with all content types
- [x] Load plugin with `include: ['rules']` - only rules returned
- [x] Load plugin with `exclude: ['hooks']` - hooks filtered out
- [x] Load disabled plugin returns empty result
- [x] Load with explicit version overrides source ref
- [x] Error for invalid source format
- [x] Error for non-existent local path

### 6.3 Test Fixtures

Use existing fixtures at `tests/fixtures/claude-plugins/` for local plugin tests.

For Git tests, mock the GitLoader similar to `tests/unit/loaders/git.test.ts`.

## 7. Integration Points

- **Imports from**:
  - `src/loaders/git.ts` - `GitLoader`, `parseGitSource`
  - `src/loaders/local.ts` - `LocalLoader`
  - `src/loaders/claude-plugin.ts` - `ClaudePluginLoader`
  - `src/utils/plugin-cache.ts` - `PluginCache`, `generatePluginId`
  - `src/loaders/base.ts` - `Loader`, `LoadResult`, `emptyLoadResultWithSource`

- **Exports to**: 
  - `src/loaders/index.ts` - Add `PluginLoader`, `createPluginLoader`
  - Used by sync pipeline when processing `config.yaml` `use.plugins` section

- **Config**: Already defined in `src/config/types.ts` as `PluginConfig`

## 8. Acceptance Criteria

- [x] All tests pass (`npm test -- plugin.test.ts`)
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)
- [x] Exports added to `src/loaders/index.ts`
- [x] Plugin loader correctly handles all source types (git, local)
- [x] Content filtering works with include/exclude
- [x] Disabled plugins return empty results
- [x] Version pinning works (config.version overrides source)

## 9. Out of Scope

- Plugin marketplace discovery/browsing (future feature)
- Plugin dependency resolution (not in official spec)
- Automatic version updates (handled by T151)
- Plugin CLI commands (handled by T160)

## 10. Usage Example

```yaml
# .ai-tool-sync/config.yaml
version: 1.0.0
project_name: my-project

use:
  plugins:
    - name: typescript-standards
      source: github:anthropics/claude-typescript@v1.0.0
      enabled: true
      include: [rules, personas]
    
    - name: security-rules
      source: github:company/security-plugin@v2.0.0
      enabled: true
      exclude: [commands]  # Don't want their commands
    
    - name: local-customizations
      source: ./plugins/local
      enabled: true
      
    - name: experimental
      source: github:user/experimental@main
      enabled: false  # Disabled for now
```

