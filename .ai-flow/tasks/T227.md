# T227: Implement Persona Inheritance

> **Priority**: P2 | **Wave**: 6 | **Track**: B (Persona Composition)
> **Depends on**: T040-T046 ✅ (Parsers complete)
> **Estimated complexity**: Medium

## 1. Objective

Implement persona inheritance using an `extends` field in frontmatter, allowing personas to inherit from a base persona. Child frontmatter fields override parent fields, and content sections are concatenated (parent first, then child). This enables creating specialized personas that share common traits without duplicating content, improving maintainability and reducing configuration overhead.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/parsers/persona.ts` - **Exact pattern to copy**: `parsePersona()`, validation flow, defaults application
- `src/parsers/types.ts` - **Lines 76-90**: `BaseFrontmatter`, `ParsedContent<T>` interfaces
- `src/loaders/local.ts` - **Lines 189-261**: How personas are loaded and collected
- `src/cli/commands/sync.ts` - **Lines 170-178**: Where resolved content is created (integration point)
- `tests/unit/parsers/persona.test.ts` - **Test patterns**: Validation, parsing, filtering tests

## 3. File Structure

```
src/
├── parsers/
│   ├── persona.ts            # Add extends field, resolvePersonaInheritance()
│   └── types.ts              # No changes needed (extends is persona-specific)
tests/
└── unit/
    └── parsers/
        └── persona.test.ts   # Add inheritance resolution tests
```

## 4. Interfaces & Types

### 4.1 Extended Persona Interface

```typescript
// In src/parsers/persona.ts - Modify existing Persona interface

export interface Persona extends BaseFrontmatter {
  name: string;
  /** Name of parent persona to inherit from */
  extends?: string;
  tools?: PersonaTool[];
  model?: string;
  traits?: Record<string, unknown>;
  cursor?: CursorExtension;
  claude?: ClaudeExtension;
  factory?: FactoryExtension;
}
```

### 4.2 New Resolution Types

```typescript
// In src/parsers/persona.ts

/**
 * Options for persona inheritance resolution
 */
export interface ResolvePersonaInheritanceOptions {
  /** Maximum inheritance depth (default: 10) */
  maxDepth?: number;
}

/**
 * Result of inheritance resolution
 */
export interface ResolvePersonaInheritanceResult {
  /** Resolved personas with inheritance applied */
  personas: ParsedPersona[];
  /** Warnings for non-fatal issues (e.g., missing parent) */
  warnings: InheritanceWarning[];
}

/**
 * Warning during inheritance resolution
 */
export interface InheritanceWarning {
  /** Persona name that has the issue */
  persona: string;
  /** Warning message */
  message: string;
  /** File path if available */
  filePath?: string;
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use `Result<T, E>` for errors that should stop processing (see `src/utils/result.ts`)
- [x] Return warnings array for non-fatal issues (missing parent → skip inheritance)
- [x] No `any` types - use `unknown` + type guards
- [x] Export new functions from `src/parsers/index.ts`
- [x] Run `npm run lint --fix` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Validate `extends` Field in Parser

```typescript
// ❌ WRONG - Validating extends target exists in parser
// Parser doesn't have access to other personas
if (data.extends && !personaExists(data.extends)) {
  errors.push({ path: 'extends', message: 'Parent not found' });
}

// ✅ CORRECT - Only validate extends is a non-empty string in parser
// Resolution happens later with access to all personas
if (data.extends !== undefined) {
  if (typeof data.extends !== 'string') {
    errors.push({
      path: 'extends',
      message: 'extends must be a string',
      value: data.extends,
    });
  } else if (data.extends.trim() === '') {
    errors.push({
      path: 'extends',
      message: 'extends cannot be empty',
      value: data.extends,
    });
  }
}
```

#### 5.2.2 Detect Circular References

```typescript
// ✅ CORRECT - Track ancestry to detect cycles
function resolveInheritanceChain(
  persona: ParsedPersona,
  personaMap: Map<string, ParsedPersona>,
  visited: Set<string>,
  maxDepth: number
): Result<ParsedPersona, InheritanceError> {
  const name = persona.frontmatter.name;
  
  // Check for circular reference
  if (visited.has(name)) {
    const cycle = [...visited, name].join(' → ');
    return err({
      type: 'circular',
      message: `Circular inheritance detected: ${cycle}`,
      persona: name,
    });
  }
  
  // Check depth limit
  if (visited.size >= maxDepth) {
    return err({
      type: 'depth',
      message: `Maximum inheritance depth (${maxDepth}) exceeded`,
      persona: name,
    });
  }
  
  // No parent - return as-is
  const parentName = persona.frontmatter.extends;
  if (!parentName) {
    return ok(persona);
  }
  
  // Resolve parent first
  visited.add(name);
  const parent = personaMap.get(parentName);
  
  if (!parent) {
    // Return warning, not error - inheritance fails gracefully
    return ok(persona); // Return unresolved persona
  }
  
  // Recursively resolve parent
  const parentResult = resolveInheritanceChain(parent, personaMap, visited, maxDepth);
  if (!parentResult.ok) {
    return parentResult;
  }
  
  // Merge parent into child
  return ok(mergePersonas(parentResult.value, persona));
}
```

#### 5.2.3 Merge Strategy

```typescript
// ✅ CORRECT - Child frontmatter overrides parent, content concatenates
function mergePersonas(parent: ParsedPersona, child: ParsedPersona): ParsedPersona {
  // Deep merge frontmatter: child values override parent
  const mergedFrontmatter: Persona = {
    // Start with parent values
    ...parent.frontmatter,
    // Override with child values (excluding undefined)
    ...Object.fromEntries(
      Object.entries(child.frontmatter).filter(([_, v]) => v !== undefined)
    ),
    // Name is always from child
    name: child.frontmatter.name,
    // Remove extends from resolved persona (inheritance is resolved)
  };
  delete (mergedFrontmatter as { extends?: string }).extends;
  
  // Deep merge platform extensions
  if (parent.frontmatter.cursor || child.frontmatter.cursor) {
    mergedFrontmatter.cursor = {
      ...parent.frontmatter.cursor,
      ...child.frontmatter.cursor,
    };
  }
  if (parent.frontmatter.claude || child.frontmatter.claude) {
    mergedFrontmatter.claude = {
      ...parent.frontmatter.claude,
      ...child.frontmatter.claude,
    };
  }
  if (parent.frontmatter.factory || child.frontmatter.factory) {
    mergedFrontmatter.factory = {
      ...parent.frontmatter.factory,
      ...child.frontmatter.factory,
    };
  }
  
  // Deep merge traits
  if (parent.frontmatter.traits || child.frontmatter.traits) {
    mergedFrontmatter.traits = {
      ...parent.frontmatter.traits,
      ...child.frontmatter.traits,
    };
  }
  
  // Concatenate content: parent first, then child
  const separator = '\n\n---\n\n'; // Visual separator between inherited sections
  const mergedContent = parent.content.trim() && child.content.trim()
    ? `${parent.content.trim()}${separator}${child.content.trim()}`
    : parent.content.trim() || child.content.trim();
  
  return {
    frontmatter: mergedFrontmatter,
    content: mergedContent,
    // Preserve child's filePath (where the actual file is)
    ...(child.filePath !== undefined ? { filePath: child.filePath } : {}),
  };
}
```

#### 5.2.4 Main Resolution Function

```typescript
/**
 * Resolve inheritance for all personas
 * 
 * @param personas - Array of parsed personas
 * @param options - Resolution options
 * @returns Resolved personas with inheritance applied
 */
export function resolvePersonaInheritance(
  personas: ParsedPersona[],
  options: ResolvePersonaInheritanceOptions = {}
): Result<ResolvePersonaInheritanceResult, ParseError> {
  const maxDepth = options.maxDepth ?? 10;
  const warnings: InheritanceWarning[] = [];
  const resolved: ParsedPersona[] = [];
  
  // Build name → persona map for lookups
  const personaMap = new Map<string, ParsedPersona>();
  for (const persona of personas) {
    personaMap.set(persona.frontmatter.name, persona);
  }
  
  // Check for duplicate names (would cause issues)
  if (personaMap.size !== personas.length) {
    const seen = new Set<string>();
    for (const persona of personas) {
      if (seen.has(persona.frontmatter.name)) {
        return err(createParseError(
          `Duplicate persona name: ${persona.frontmatter.name}`,
          { filePath: persona.filePath }
        ));
      }
      seen.add(persona.frontmatter.name);
    }
  }
  
  // Resolve each persona
  for (const persona of personas) {
    const visited = new Set<string>();
    const result = resolveInheritanceChain(persona, personaMap, visited, maxDepth);
    
    if (!result.ok) {
      // Circular references are errors
      return err(createParseError(result.error.message, { filePath: persona.filePath }));
    }
    
    // Check if inheritance was skipped due to missing parent
    if (persona.frontmatter.extends && !personaMap.has(persona.frontmatter.extends)) {
      warnings.push({
        persona: persona.frontmatter.name,
        message: `Parent persona '${persona.frontmatter.extends}' not found, inheritance skipped`,
        filePath: persona.filePath,
      });
    }
    
    resolved.push(result.value);
  }
  
  return ok({ personas: resolved, warnings });
}
```

### 5.3 Edge Cases to Handle

- [ ] `extends` field is undefined → Return persona unchanged
- [ ] `extends` field is empty string → Validation error in parser
- [ ] Parent persona not found → Warning + return child unchanged
- [ ] Circular reference (A extends B, B extends A) → Error
- [ ] Self-reference (A extends A) → Error
- [ ] Deep inheritance (A extends B extends C) → Resolve recursively
- [ ] Max depth exceeded → Error with clear message
- [ ] Duplicate persona names → Error before resolution
- [ ] Parent has no content, child has content → Use child content only
- [ ] Parent has content, child has no content → Use parent content only
- [ ] Both have content → Concatenate with separator
- [ ] Platform extensions partial overlap → Merge with child priority

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/parsers/persona.test.ts - ADD to existing file

describe('Persona Inheritance', () => {
  describe('parsePersona() with extends', () => {
    it('should parse persona with valid extends field', () => { /* ... */ });
    it('should reject non-string extends', () => { /* ... */ });
    it('should reject empty extends', () => { /* ... */ });
  });

  describe('resolvePersonaInheritance()', () => {
    describe('basic inheritance', () => {
      it('should merge parent frontmatter into child', () => { /* ... */ });
      it('should concatenate parent and child content', () => { /* ... */ });
      it('should allow child to override parent fields', () => { /* ... */ });
      it('should remove extends field after resolution', () => { /* ... */ });
    });

    describe('multi-level inheritance', () => {
      it('should resolve A extends B extends C', () => { /* ... */ });
      it('should respect max depth limit', () => { /* ... */ });
    });

    describe('error handling', () => {
      it('should detect circular references', () => { /* ... */ });
      it('should detect self-references', () => { /* ... */ });
      it('should error on duplicate persona names', () => { /* ... */ });
    });

    describe('warnings', () => {
      it('should warn when parent not found', () => { /* ... */ });
      it('should include persona name and filePath in warning', () => { /* ... */ });
    });

    describe('platform extensions', () => {
      it('should merge cursor extensions', () => { /* ... */ });
      it('should merge claude extensions', () => { /* ... */ });
      it('should merge factory extensions', () => { /* ... */ });
    });
  });
});
```

### 6.2 Required Test Cases

```typescript
// Test: Basic inheritance
it('should merge parent frontmatter into child', () => {
  const parent: ParsedPersona = {
    frontmatter: {
      name: 'base-implementer',
      description: 'Base implementer',
      tools: ['read', 'write', 'edit'],
      model: 'default',
      targets: ['cursor', 'claude'],
    },
    content: '# Base Implementer\n\nBase content here.',
  };
  
  const child: ParsedPersona = {
    frontmatter: {
      name: 'senior-implementer',
      extends: 'base-implementer',
      description: 'Senior implementer', // Override
      tools: ['read', 'write', 'edit', 'execute'], // Override
      // model: inherits 'default'
      // targets: inherits ['cursor', 'claude']
    },
    content: '## Senior Additions\n\nAdditional content.',
    filePath: 'personas/senior-implementer.md',
  };
  
  const result = resolvePersonaInheritance([parent, child]);
  
  expect(result.ok).toBe(true);
  if (result.ok) {
    const senior = result.value.personas.find(p => p.frontmatter.name === 'senior-implementer');
    expect(senior).toBeDefined();
    expect(senior!.frontmatter.description).toBe('Senior implementer');
    expect(senior!.frontmatter.tools).toEqual(['read', 'write', 'edit', 'execute']);
    expect(senior!.frontmatter.model).toBe('default'); // Inherited
    expect(senior!.frontmatter.targets).toEqual(['cursor', 'claude']); // Inherited
    expect(senior!.frontmatter.extends).toBeUndefined(); // Removed after resolution
    expect(senior!.content).toContain('Base content here');
    expect(senior!.content).toContain('Senior Additions');
    expect(senior!.filePath).toBe('personas/senior-implementer.md');
  }
});

// Test: Circular reference detection
it('should detect circular references', () => {
  const a: ParsedPersona = {
    frontmatter: { name: 'persona-a', extends: 'persona-b' },
    content: 'A',
  };
  const b: ParsedPersona = {
    frontmatter: { name: 'persona-b', extends: 'persona-a' },
    content: 'B',
  };
  
  const result = resolvePersonaInheritance([a, b]);
  
  expect(result.ok).toBe(false);
  if (!result.ok) {
    expect(result.error.message).toContain('Circular');
  }
});

// Test: Missing parent warning
it('should warn when parent not found', () => {
  const child: ParsedPersona = {
    frontmatter: { name: 'orphan', extends: 'non-existent' },
    content: 'Content',
    filePath: 'personas/orphan.md',
  };
  
  const result = resolvePersonaInheritance([child]);
  
  expect(result.ok).toBe(true);
  if (result.ok) {
    expect(result.value.warnings).toHaveLength(1);
    expect(result.value.warnings[0].persona).toBe('orphan');
    expect(result.value.warnings[0].message).toContain('non-existent');
    expect(result.value.warnings[0].filePath).toBe('personas/orphan.md');
    // Persona returned unchanged
    expect(result.value.personas[0].frontmatter.name).toBe('orphan');
  }
});

// Test: Platform extensions merge
it('should merge platform extensions with child priority', () => {
  const parent: ParsedPersona = {
    frontmatter: {
      name: 'base',
      cursor: { alwaysApply: true, globs: ['**/*.ts'] },
      claude: { model: 'opus' },
    },
    content: 'Base',
  };
  
  const child: ParsedPersona = {
    frontmatter: {
      name: 'child',
      extends: 'base',
      cursor: { globs: ['**/*.tsx'] }, // Override globs, inherit alwaysApply
      factory: { reasoningEffort: 'high' }, // Child-only
    },
    content: 'Child',
  };
  
  const result = resolvePersonaInheritance([parent, child]);
  
  expect(result.ok).toBe(true);
  if (result.ok) {
    const resolved = result.value.personas.find(p => p.frontmatter.name === 'child');
    expect(resolved!.frontmatter.cursor).toEqual({
      alwaysApply: true, // Inherited
      globs: ['**/*.tsx'], // Overridden
    });
    expect(resolved!.frontmatter.claude).toEqual({ model: 'opus' }); // Inherited
    expect(resolved!.frontmatter.factory).toEqual({ reasoningEffort: 'high' }); // Child-only
  }
});
```

## 7. Integration Points

- **Imports from**:
  - `src/utils/result.ts` - `Result`, `ok`, `err`
  - `src/parsers/types.ts` - `ParseError`, `createParseError`

- **Exports to**:
  - `src/parsers/index.ts` - Export `resolvePersonaInheritance`, `ResolvePersonaInheritanceResult`, `InheritanceWarning`
  - `src/cli/commands/sync.ts` - Call after loading, before generation

- **Integration in sync.ts**:
  ```typescript
  // In loadContent() or after it, before createResolvedContent()
  
  // Resolve persona inheritance
  const inheritanceResult = resolvePersonaInheritance(merged.personas);
  if (!inheritanceResult.ok) {
    // Handle error (e.g., circular reference)
    logger.error(inheritanceResult.error.message);
    // Could add to loadResult.errors or return early
  } else {
    merged.personas = inheritanceResult.value.personas;
    
    // Log warnings
    for (const warning of inheritanceResult.value.warnings) {
      logger.warn(`${warning.persona}: ${warning.message}`);
    }
  }
  ```

- **Config**: No schema changes needed; `extends` is a frontmatter field

## 8. Acceptance Criteria

- [ ] `parsePersona()` accepts and validates `extends` field
- [ ] `resolvePersonaInheritance()` resolves inheritance for all personas
- [ ] Child frontmatter overrides parent frontmatter
- [ ] Content is concatenated with parent first, separator, then child
- [ ] Platform extensions (`cursor`, `claude`, `factory`) are deep merged
- [ ] Circular references are detected and reported as errors
- [ ] Missing parent results in warning (not error), persona unchanged
- [ ] Max depth limit prevents infinite loops
- [ ] All tests pass (`npm test -- persona.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Functions exported from `src/parsers/index.ts`
- [ ] Integration added to `src/cli/commands/sync.ts`
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Rule inheritance/composition (T225)
- Conditional rules based on project context (T226)
- Multiple inheritance (persona can only extend one parent)
- Dynamic resolution of parent from external sources (all personas must be loaded first)

## 10. Implementation Checklist

1. [ ] Add `extends?: string` to `Persona` interface in `src/parsers/persona.ts`
2. [ ] Add `extends` validation to `validatePersonaFields()`
3. [ ] Add `InheritanceWarning` type
4. [ ] Add `ResolvePersonaInheritanceOptions` type
5. [ ] Add `ResolvePersonaInheritanceResult` type
6. [ ] Implement `mergePersonas()` helper function
7. [ ] Implement `resolveInheritanceChain()` helper function
8. [ ] Implement `resolvePersonaInheritance()` main function
9. [ ] Export new types and functions from `src/parsers/index.ts`
10. [ ] Integrate into `src/cli/commands/sync.ts` after content loading
11. [ ] Add tests to `tests/unit/parsers/persona.test.ts`
12. [ ] Run `npm test -- persona.test.ts`
13. [ ] Run `npm run lint --fix`
14. [ ] Run `npm run typecheck`
15. [ ] Update plan.md with T227 completion status

## 11. Example Usage

### 11.1 Base Persona (`defaults/personas/base-implementer.md`)

```yaml
---
name: base-implementer
description: Base implementation persona with common patterns
version: 1.0.0
tools:
  - read
  - write
  - edit
  - search
  - glob
  - ls
model: default
targets:
  - cursor
  - claude
  - factory
---

# Base Implementer

## Core Principles

- Write clean, maintainable code
- Follow established patterns
- Test your changes
```

### 11.2 Specialized Persona (`.ai-tool-sync/personas/senior-dev.md`)

```yaml
---
name: senior-dev
extends: base-implementer
description: Senior developer with full access
tools:
  - read
  - write
  - edit
  - execute   # Added
  - search
  - glob
  - fetch     # Added
  - ls
claude:
  model: opus  # Override for Claude
---

# Senior Developer Additions

## Additional Responsibilities

- Code review authority
- Architecture decisions
- Mentoring junior developers
```

### 11.3 Resolved Output

After resolution, `senior-dev` would have:

```yaml
# Frontmatter (merged):
name: senior-dev
description: Senior developer with full access
version: 1.0.0
tools: [read, write, edit, execute, search, glob, fetch, ls]
model: default
targets: [cursor, claude, factory]
claude:
  model: opus
```

```markdown
# Content (concatenated):

# Base Implementer

## Core Principles

- Write clean, maintainable code
- Follow established patterns
- Test your changes

---

# Senior Developer Additions

## Additional Responsibilities

- Code review authority
- Architecture decisions
- Mentoring junior developers
```

