# T156: Add Plugin hooks.json Parsing

> **Priority**: P2 | **Wave**: 2 | **Track**: A (Plugin Infrastructure)
> **Depends on**: T155
> **Estimated complexity**: Medium

## 1. Objective

Enhance the Claude plugin loader to parse the official `hooks/hooks.json` file format from Claude plugins. Currently, the loader only parses hooks from `settings.json` with a limited set of events (PreToolUse, PostToolUse, Notification, Stop). This task adds support for the full Claude Code plugin hooks specification, including all 9 event types, matcher patterns for tool filtering, and hook types (command, validation, notification). This enables ai-tool-sync to fully consume Claude Code plugins.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/loaders/claude-plugin.ts` lines 840-919 - **Current hooks loading** from settings.json (extend this pattern)
- `src/parsers/hook.ts` lines 38-53 - **HookEvent types** already include all Claude events
- `src/loaders/claude-plugin.ts` lines 80-92 - **ClaudeHook interface** to extend
- `tests/unit/loaders/claude-plugin.test.ts` lines 127-162 - **Test pattern for hooks loading**
- `tests/fixtures/claude-plugins/hooks-plugin/settings.json` - **Existing hooks fixture** (create similar for hooks.json)

## 3. File Structure

```
src/
├── loaders/
│   └── claude-plugin.ts      # Extend loadHooksFromPath method
tests/
├── fixtures/
│   └── claude-plugins/
│       └── full-hooks-plugin/   # NEW: Test fixture with hooks/hooks.json
│           └── hooks/
│               └── hooks.json
└── unit/
    └── loaders/
        └── claude-plugin.test.ts   # Add new test cases
```

## 4. Interfaces & Types

Extend the `ClaudeHook` interface to support full hooks.json format:

```typescript
// In src/loaders/claude-plugin.ts - EXTEND existing interface

/**
 * Claude hook configuration (extended for hooks.json format)
 */
export interface ClaudeHook {
  /** Hook identifier */
  name?: string;
  /** Tool/event matcher pattern (e.g., "Bash(*rm*)", "Write|Edit") */
  match?: string;
  /** Command to execute (for command type) */
  command?: string;
  /** Script path to execute (alternative to command) */
  script?: string;
  /** Action to take: allow, deny, warn, or ask */
  action?: 'allow' | 'deny' | 'warn' | 'ask';
  /** Message to display */
  message?: string;
  /** Hook type (new for hooks.json) */
  type?: 'command' | 'validation' | 'notification';
  /** Timeout in milliseconds (new for hooks.json) */
  timeout?: number;
}

/**
 * Full hooks.json structure
 */
export interface ClaudeHooksJson {
  hooks: {
    UserPromptSubmit?: ClaudeHook[];
    PreToolUse?: ClaudeHook[];
    PostToolUse?: ClaudeHook[];
    Notification?: ClaudeHook[];
    Stop?: ClaudeHook[];
    SubagentStop?: ClaudeHook[];
    SessionStart?: ClaudeHook[];
    SessionEnd?: ClaudeHook[];
    PreCompact?: ClaudeHook[];
  };
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [ ] Use existing `loadHooksFromPath` method structure (extend, don't replace)
- [ ] Use `HookEvent` type from `src/parsers/hook.ts` for event mapping
- [ ] Return `ParsedHook[]` following existing pattern
- [ ] Handle both `hooks/hooks.json` and legacy `settings.json` formats
- [ ] Log using `logger.debug()` for tracing

### 5.2 Critical Logic (Pitfall Prevention)

Update `findHooksFile` to prioritize `hooks/hooks.json`:

```typescript
// ❌ WRONG - Current implementation (settings.json first)
private findHooksFile(pluginPath: string): string | undefined {
  const candidates = [
    path.join(pluginPath, 'hooks', 'hooks.json'),
    path.join(pluginPath, 'settings.json'),
  ];
  // ...
}

// ✅ CORRECT - Already correct, just verify this order is maintained
```

Update `loadHooksFromPath` to detect and parse both formats:

```typescript
private async loadHooksFromPath(
  hooksPath: string,
  pluginRoot: string,
  _options?: ClaudePluginLoaderOptions
): Promise<{ items: ParsedHook[]; errors: LoadError[] }> {
  const items: ParsedHook[] = [];
  const errors: LoadError[] = [];

  if (!this.fileExists(hooksPath)) {
    return { items, errors };
  }

  try {
    const content = await fs.promises.readFile(hooksPath, 'utf-8');
    // Resolve ${CLAUDE_PLUGIN_ROOT} before parsing
    const resolvedContent = resolvePluginRootVariable(content, pluginRoot);
    const parsed = JSON.parse(resolvedContent);

    // Detect format: hooks.json has { hooks: { ... } }, settings.json has hooks at root or nested
    const hooksObject = this.extractHooksObject(parsed);
    
    if (hooksObject) {
      for (const [eventType, hooks] of Object.entries(hooksObject)) {
        if (!Array.isArray(hooks)) continue;

        for (const hook of hooks) {
          const parsedHook = this.transformHook(hook, eventType, hooksPath);
          items.push(parsedHook);
        }
      }
    }
  } catch (error) {
    errors.push({
      type: 'hook',
      path: hooksPath,
      message: `Failed to parse hooks file: ${error instanceof Error ? error.message : String(error)}`,
    });
  }

  return { items, errors };
}

/**
 * Extract hooks object from either hooks.json or settings.json format
 */
private extractHooksObject(parsed: unknown): Record<string, ClaudeHook[]> | null {
  if (!parsed || typeof parsed !== 'object') {
    return null;
  }

  const obj = parsed as Record<string, unknown>;

  // hooks.json format: { hooks: { PreToolUse: [...], ... } }
  if ('hooks' in obj && typeof obj.hooks === 'object' && obj.hooks !== null) {
    return obj.hooks as Record<string, ClaudeHook[]>;
  }

  // settings.json format: { hooks: { PreToolUse: [...], ... }, ... }
  // Same structure, so this works for both
  return null;
}
```

Update event mapping to include all Claude events:

```typescript
// ❌ WRONG - Current implementation (only 4 events)
const eventMap: Record<string, HookEvent> = {
  PreToolUse: 'PreToolUse',
  PostToolUse: 'PostToolUse',
  Notification: 'PreMessage',
  Stop: 'PostMessage',
};

// ✅ CORRECT - All 9 Claude events
const eventMap: Record<string, HookEvent> = {
  // Core events (direct mapping)
  PreToolUse: 'PreToolUse',
  PostToolUse: 'PostToolUse',
  UserPromptSubmit: 'UserPromptSubmit',
  // Claude-specific events (direct mapping - already in HookEvent type)
  Notification: 'Notification',
  Stop: 'Stop',
  SubagentStop: 'SubagentStop',
  SessionStart: 'SessionStart',
  SessionEnd: 'SessionEnd',
  PreCompact: 'PreCompact',
};
```

### 5.3 Edge Cases to Handle

- [ ] Empty hooks object `{}` → Return empty array
- [ ] Event type with empty array `{ PreToolUse: [] }` → Skip, no hooks created
- [ ] Unknown event type → Log warning, skip (don't fail entire file)
- [ ] Hook without name → Generate name from event type + index
- [ ] Both `command` and `script` present → Prefer `command`
- [ ] `${CLAUDE_PLUGIN_ROOT}` in command/script paths → Resolve before storing
- [ ] Invalid JSON → Return error in errors array, continue loading other content

## 6. Test Requirements

### 6.1 Test Fixture

Create `tests/fixtures/claude-plugins/full-hooks-plugin/hooks/hooks.json`:

```json
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "name": "prompt-filter",
        "type": "validation",
        "command": "sh -c '${CLAUDE_PLUGIN_ROOT}/hooks/filter-prompt.sh'",
        "message": "Filtering user prompt"
      }
    ],
    "PreToolUse": [
      {
        "name": "security-check",
        "match": "Bash(*rm*)|Bash(*sudo*)",
        "type": "command",
        "command": "sh -c './hooks/security-check.sh'",
        "action": "warn",
        "message": "Potentially dangerous command detected"
      },
      {
        "name": "file-guard",
        "match": "Write(*.env*)|Edit(*.env*)",
        "action": "deny",
        "message": "Cannot modify .env files"
      }
    ],
    "PostToolUse": [
      {
        "name": "format-on-edit",
        "match": "Write|Edit",
        "type": "command",
        "command": "npx prettier --write"
      }
    ],
    "Stop": [
      {
        "name": "cleanup",
        "type": "notification",
        "message": "Agent stopped"
      }
    ],
    "SessionStart": [
      {
        "name": "init-workspace",
        "type": "command",
        "command": "sh -c './hooks/init.sh'"
      }
    ],
    "SessionEnd": [
      {
        "name": "save-context",
        "type": "command",
        "command": "sh -c './hooks/save-context.sh'"
      }
    ]
  }
}
```

### 6.2 Test File Structure

Add to `tests/unit/loaders/claude-plugin.test.ts`:

```typescript
describe('load() - hooks from hooks/hooks.json', () => {
  const fullHooksPluginPath = path.join(FIXTURES_PATH, 'full-hooks-plugin');

  describe('event types', () => {
    it('should parse all Claude event types', async () => { /* ... */ });
    it('should map UserPromptSubmit event correctly', async () => { /* ... */ });
    it('should map session lifecycle events correctly', async () => { /* ... */ });
  });

  describe('matcher patterns', () => {
    it('should preserve complex match patterns', async () => { /* ... */ });
    it('should handle pipe-separated matchers', async () => { /* ... */ });
  });

  describe('hook types', () => {
    it('should preserve hook type (command/validation/notification)', async () => { /* ... */ });
  });

  describe('path resolution', () => {
    it('should resolve ${CLAUDE_PLUGIN_ROOT} in command paths', async () => { /* ... */ });
  });
});
```

### 6.3 Required Test Cases

- [ ] **All events**: Parse all 9 Claude event types

```typescript
it('should parse all Claude event types', async () => {
  const result = await loader.load(`claude-plugin:${fullHooksPluginPath}`);

  expect(result.hooks.length).toBeGreaterThanOrEqual(6);
  
  const events = result.hooks.map(h => h.frontmatter.event);
  expect(events).toContain('UserPromptSubmit');
  expect(events).toContain('PreToolUse');
  expect(events).toContain('PostToolUse');
  expect(events).toContain('Stop');
  expect(events).toContain('SessionStart');
  expect(events).toContain('SessionEnd');
});
```

- [ ] **Matcher patterns**: Preserve complex patterns

```typescript
it('should preserve complex match patterns', async () => {
  const result = await loader.load(`claude-plugin:${fullHooksPluginPath}`);

  const securityHook = result.hooks.find(h => h.frontmatter.name === 'security-check');
  expect(securityHook).toBeDefined();
  expect(securityHook!.frontmatter.tool_match).toBe('Bash(*rm*)|Bash(*sudo*)');
});
```

- [ ] **Plugin root variable**: Resolve paths correctly

```typescript
it('should resolve ${CLAUDE_PLUGIN_ROOT} in command paths', async () => {
  const result = await loader.load(`claude-plugin:${fullHooksPluginPath}`);

  const promptFilter = result.hooks.find(h => h.frontmatter.name === 'prompt-filter');
  expect(promptFilter).toBeDefined();
  // Should contain the resolved absolute path, not the variable
  expect(promptFilter!.frontmatter.execute).not.toContain('${CLAUDE_PLUGIN_ROOT}');
  expect(promptFilter!.frontmatter.execute).toContain(fullHooksPluginPath);
});
```

- [ ] **Hook action preservation**: Preserve deny/warn/ask actions

```typescript
it('should preserve hook action types', async () => {
  const result = await loader.load(`claude-plugin:${fullHooksPluginPath}`);

  const fileGuard = result.hooks.find(h => h.frontmatter.name === 'file-guard');
  expect(fileGuard).toBeDefined();
  // Note: action may need to be stored in a new field or mapped
  expect(fileGuard!.content).toContain('Cannot modify .env files');
});
```

- [ ] **Priority**: hooks/hooks.json takes precedence over settings.json

```typescript
it('should prefer hooks/hooks.json over settings.json when both exist', async () => {
  // Create a test case where both files exist
  // Verify hooks.json hooks are loaded, not settings.json
});
```

## 7. Integration Points

- **Imports from**: 
  - `src/utils/plugin-cache.ts` - use `resolvePluginRootVariable()`
  - `src/parsers/hook.ts` - use `HookEvent` type
- **Exports to**: Used by existing loader pipeline, no new exports
- **Config**: No config schema changes needed

## 8. Acceptance Criteria

- [x] All existing hook loading tests still pass
- [x] New hooks.json format tests pass
- [x] All 9 Claude event types are parsed correctly
- [x] Matcher patterns are preserved without modification
- [x] `${CLAUDE_PLUGIN_ROOT}` is resolved in command/script paths
- [x] Backwards compatible with settings.json format
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)

## 9. Out of Scope

- Plugin MCP server extraction (handled in T157)
- Git-based plugin loading (handled in T158)
- Hook execution (ai-tool-sync only generates configs)
- Custom hook types beyond command/validation/notification
- Hook timeout enforcement

## 10. Implementation Checklist

1. [x] Read existing hook loading code (`src/loaders/claude-plugin.ts` lines 840-919)
2. [x] Create test fixture at `tests/fixtures/claude-plugins/full-hooks-plugin/hooks/hooks.json`
3. [x] Extend `ClaudeHook` interface with `type` and `timeout` fields
4. [x] Add `ClaudeHooksJson` interface for type safety
5. [x] Create `extractHooksObject` helper method
6. [x] Update `transformHook` to handle all 9 event types
7. [x] Update `transformHook` to resolve `${CLAUDE_PLUGIN_ROOT}` in paths
8. [x] Write test cases in `tests/unit/loaders/claude-plugin.test.ts`
9. [x] Run `npm test -- claude-plugin.test.ts` to verify
10. [x] Run `npm run lint` to verify no lint errors

