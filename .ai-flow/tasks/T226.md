# T226: Implement Conditional Rules

> **Priority**: P2 | **Wave**: 6 | **Track**: A (Rule Composition)
> **Depends on**: T225 ✅ (include syntax), T040-T046 ✅ (parsers complete)
> **Estimated complexity**: Medium

## 1. Objective

Implement a `when:` frontmatter directive that allows rules to be conditionally included based on project context. This enables rules to self-select based on project characteristics—for example, TypeScript-specific rules only apply when the project uses TypeScript, or database rules only apply when Prisma is detected. Conditions are evaluated at sync time using **namespaced identifiers** that dynamically check dependencies from various package managers, file existence, and user-defined variables.

**Design Goals:**
- **Language-agnostic**: Support Node.js, Python, Go, Rust, PHP, Ruby, Dart, Java, .NET
- **No hardcoded lists**: Any package name can be checked dynamically
- **Clean syntax**: Simple existence checks don't require `== true`

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/transformers/conditional-content.ts` - **Lines 35-63**: `parseCondition()` pattern for parsing expressions with operators
- `src/parsers/rule.ts` - **Lines 85-222**: `validateRuleFields()` pattern for frontmatter validation
- `src/parsers/rule.ts` - **Lines 268-312**: `parseRule()` pattern for parsing with Result type
- `src/utils/fs.ts` - **Lines 16-23, 40-45**: `fileExists()`, `readFile()` for detection
- `src/utils/result.ts` - **Lines 106-114**: `andThen()` for chaining Result operations
- `tests/unit/transformers/conditional-content.test.ts` - Test patterns for transformers

## 3. File Structure

```
src/
├── transformers/
│   ├── condition-evaluator.ts   # Main implementation
│   └── index.ts                 # Add export
tests/
├── unit/
│   └── transformers/
│       └── condition-evaluator.test.ts  # Unit tests
└── fixtures/
    └── conditional-rules/               # Test fixtures
        ├── package.json                 # Mock Node.js project
        ├── requirements.txt             # Mock Python project
        ├── tsconfig.json                # For file existence test
        └── rules/
            ├── typescript-only.md
            ├── react-only.md
            └── always-applies.md
```

## 4. Interfaces & Types

```typescript
// In src/transformers/condition-evaluator.ts

/**
 * Supported package manager ecosystems
 */
export type PackageEcosystem = 
  | 'npm'       // Node.js - package.json
  | 'pip'       // Python - requirements.txt, pyproject.toml, Pipfile
  | 'go'        // Go - go.mod
  | 'cargo'     // Rust - Cargo.toml
  | 'composer'  // PHP - composer.json
  | 'gem'       // Ruby - Gemfile
  | 'pub'       // Dart/Flutter - pubspec.yaml
  | 'maven'     // Java - pom.xml
  | 'gradle'    // Java/Kotlin - build.gradle
  | 'nuget';    // .NET - *.csproj

/**
 * Namespace prefixes for condition identifiers
 */
export type ConditionNamespace =
  | PackageEcosystem  // npm:react, pip:django, etc.
  | 'file'            // file:tsconfig.json
  | 'dir'             // dir:.github/workflows
  | 'pkg'             // pkg:type (package.json fields)
  | 'var';            // var:custom_variable (user-defined)

/**
 * Parsed identifier with namespace
 */
export interface ParsedIdentifier {
  /** The namespace prefix */
  namespace: ConditionNamespace;
  /** The identifier after the colon */
  name: string;
}

/**
 * A single condition (can be existence check or comparison)
 */
export interface ParsedCondition {
  /** The namespaced identifier */
  identifier: ParsedIdentifier;
  /** Whether this is negated (!) */
  negated: boolean;
  /** Comparison operator (if any) - null means existence check */
  operator: ComparisonOperator | null;
  /** Value to compare (if operator present) */
  value: string | number | boolean | null;
}

/**
 * Supported comparison operators
 */
export type ComparisonOperator = '==' | '!=' | '>' | '<' | '>=' | '<=';

/**
 * Supported logical operators
 */
export type LogicalOperator = '&&' | '||';

/**
 * A compound condition with logical operators
 */
export interface CompoundCondition {
  /** Individual conditions */
  conditions: ParsedCondition[];
  /** Logical operators between conditions (length = conditions.length - 1) */
  operators: LogicalOperator[];
}

/**
 * Result of evaluating a condition
 */
export interface EvaluationResult {
  /** Whether the condition passed */
  matches: boolean;
  /** Human-readable explanation of evaluation */
  reason: string;
  /** Identifiers that were checked */
  checkedIdentifiers: string[];
}

/**
 * Project context - lazily populated as conditions are evaluated
 */
export interface ProjectContext {
  /** Project root directory */
  projectRoot: string;
  /** Cached dependency lookups by ecosystem */
  dependencyCache: Map<PackageEcosystem, Map<string, string | boolean>>;
  /** Cached file existence checks */
  fileCache: Map<string, boolean>;
  /** User-defined variables from config.yaml */
  variables: Record<string, string | number | boolean>;
  /** Package.json contents (if exists) */
  packageJson?: Record<string, unknown>;
}

/**
 * Error types for condition evaluation
 */
export type ConditionErrorCode =
  | 'PARSE_ERROR'
  | 'UNKNOWN_NAMESPACE'
  | 'INVALID_OPERATOR'
  | 'ECOSYSTEM_NOT_FOUND';

/**
 * Condition evaluation error
 */
export interface ConditionError {
  code: ConditionErrorCode;
  message: string;
  /** The condition expression that caused the error */
  expression: string;
  /** Position in expression where error occurred (if applicable) */
  position?: number;
}
```

## 5. Condition Syntax Reference

### 5.1 Namespaced Identifiers

| Prefix | Description | Files Checked | Example |
|--------|-------------|---------------|---------|
| `npm:` | Node.js packages | `package.json` | `npm:react`, `npm:@types/node` |
| `pip:` | Python packages | `requirements.txt`, `pyproject.toml`, `setup.py`, `Pipfile` | `pip:django`, `pip:pytest` |
| `go:` | Go modules | `go.mod` | `go:github.com/gin-gonic/gin` |
| `cargo:` | Rust crates | `Cargo.toml` | `cargo:serde`, `cargo:tokio` |
| `composer:` | PHP packages | `composer.json` | `composer:laravel/framework` |
| `gem:` | Ruby gems | `Gemfile`, `*.gemspec` | `gem:rails`, `gem:rspec` |
| `pub:` | Dart/Flutter packages | `pubspec.yaml` | `pub:flutter`, `pub:dio` |
| `maven:` | Maven artifacts | `pom.xml` | `maven:org.springframework` |
| `gradle:` | Gradle dependencies | `build.gradle`, `build.gradle.kts` | `gradle:kotlin` |
| `nuget:` | NuGet packages | `*.csproj`, `packages.config` | `nuget:Newtonsoft.Json` |
| `file:` | File existence | Any file path | `file:tsconfig.json`, `file:src/index.ts` |
| `dir:` | Directory existence | Any directory path | `dir:.github/workflows`, `dir:src` |
| `pkg:` | package.json fields | `package.json` | `pkg:type`, `pkg:name` |
| `var:` | User-defined variables | `config.yaml` context section | `var:is_monorepo` |

### 5.2 Operators

| Operator | Usage | Example |
|----------|-------|---------|
| *(none)* | Existence check (truthy) | `npm:react` |
| `!` | Negation (not exists) | `!npm:react` |
| `==` | Equals | `pkg:type == "module"` |
| `!=` | Not equals | `var:env != "test"` |
| `>=`, `>`, `<=`, `<` | Numeric/version compare | `npm:react >= "18"` (future) |
| `&&` | Logical AND | `npm:react && npm:typescript` |
| `\|\|` | Logical OR | `npm:jest \|\| npm:vitest` |

### 5.3 Example Conditions

```yaml
# Simple existence (Node.js)
when: npm:typescript

# Negation
when: !npm:webpack

# Compound AND
when: npm:react && npm:typescript

# Compound OR  
when: npm:jest || npm:vitest || npm:mocha

# Mixed (AND has higher precedence)
when: npm:typescript && npm:react || npm:vue

# File existence
when: file:tsconfig.json

# Directory existence
when: dir:.github/workflows

# Package.json field comparison
when: pkg:type == "module"

# User variable
when: var:is_monorepo

# Python project
when: pip:django && pip:celery

# Go project
when: go:github.com/gin-gonic/gin

# Rust project  
when: cargo:tokio && cargo:serde

# Multi-language monorepo
when: npm:typescript || pip:mypy
```

## 6. Implementation Requirements

### 6.1 Must Follow (Project Patterns)

- [ ] Use `Result<T, E>` for errors (see `src/utils/result.ts`)
- [ ] Export from `src/transformers/index.ts`
- [ ] No `any` types - use `unknown` + type guards where needed
- [ ] Run `npm run lint --fix` after implementation
- [ ] Run `npm run typecheck` after implementation
- [ ] Follow `exactOptionalPropertyTypes` - conditionally include keys (see learnings.md T159)

### 6.2 Critical Logic (Pitfall Prevention)

#### 6.2.1 Identifier Parsing

```typescript
/**
 * Parse a namespaced identifier
 * 
 * Examples:
 * - "npm:react" → { namespace: "npm", name: "react" }
 * - "file:tsconfig.json" → { namespace: "file", name: "tsconfig.json" }
 * - "npm:@scope/package" → { namespace: "npm", name: "@scope/package" }
 */
const IDENTIFIER_PATTERN = /^([a-z]+):(.+)$/i;

function parseIdentifier(identifier: string): Result<ParsedIdentifier, ConditionError> {
  const match = IDENTIFIER_PATTERN.exec(identifier.trim());
  
  if (!match) {
    return err({
      code: 'PARSE_ERROR',
      message: `Invalid identifier format: "${identifier}". Expected "namespace:name"`,
      expression: identifier,
    });
  }
  
  const [, namespace, name] = match;
  const lowerNamespace = namespace.toLowerCase();
  
  const validNamespaces: ConditionNamespace[] = [
    'npm', 'pip', 'go', 'cargo', 'composer', 'gem', 'pub', 
    'maven', 'gradle', 'nuget', 'file', 'dir', 'pkg', 'var'
  ];
  
  if (!validNamespaces.includes(lowerNamespace as ConditionNamespace)) {
    return err({
      code: 'UNKNOWN_NAMESPACE',
      message: `Unknown namespace: "${namespace}". Valid: ${validNamespaces.join(', ')}`,
      expression: identifier,
    });
  }
  
  return ok({
    namespace: lowerNamespace as ConditionNamespace,
    name: name.trim(),
  });
}
```

#### 6.2.2 Condition Parsing (with negation support)

```typescript
/**
 * Parse a single condition term
 * 
 * Formats:
 * - "npm:react" → existence check
 * - "!npm:react" → negated existence
 * - "pkg:type == \"module\"" → comparison
 * - "var:count > 5" → numeric comparison
 */
const COMPARISON_PATTERN = /^(!?)(.+?)\s*(==|!=|>=?|<=?)\s*(.+)$/;
const EXISTENCE_PATTERN = /^(!?)(.+)$/;

function parseConditionTerm(term: string): Result<ParsedCondition, ConditionError> {
  const trimmed = term.trim();
  
  // Try comparison first
  const compMatch = COMPARISON_PATTERN.exec(trimmed);
  if (compMatch) {
    const [, negation, identifierStr, operator, valueStr] = compMatch;
    
    const identResult = parseIdentifier(identifierStr.trim());
    if (!identResult.ok) return identResult;
    
    return ok({
      identifier: identResult.value,
      negated: negation === '!',
      operator: operator as ComparisonOperator,
      value: parseValue(valueStr),
    });
  }
  
  // Existence check
  const existMatch = EXISTENCE_PATTERN.exec(trimmed);
  if (existMatch) {
    const [, negation, identifierStr] = existMatch;
    
    const identResult = parseIdentifier(identifierStr.trim());
    if (!identResult.ok) return identResult;
    
    return ok({
      identifier: identResult.value,
      negated: negation === '!',
      operator: null,
      value: null,
    });
  }
  
  return err({
    code: 'PARSE_ERROR',
    message: `Cannot parse condition: "${trimmed}"`,
    expression: trimmed,
  });
}

/**
 * Parse value from condition (handles quotes, booleans, numbers)
 */
function parseValue(valueStr: string): string | number | boolean {
  const trimmed = valueStr.trim();
  
  // Boolean
  if (trimmed === 'true') return true;
  if (trimmed === 'false') return false;
  
  // Quoted string
  if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
      (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
    return trimmed.slice(1, -1);
  }
  
  // Number
  const num = Number(trimmed);
  if (!Number.isNaN(num)) return num;
  
  // Unquoted string
  return trimmed;
}
```

#### 6.2.3 Dependency Detection by Ecosystem

```typescript
/**
 * Check if a dependency exists in the given ecosystem
 */
async function checkDependency(
  ecosystem: PackageEcosystem,
  packageName: string,
  context: ProjectContext
): Promise<Result<boolean, ConditionError>> {
  // Check cache first
  const ecosystemCache = context.dependencyCache.get(ecosystem);
  if (ecosystemCache?.has(packageName)) {
    return ok(ecosystemCache.get(packageName) !== false);
  }
  
  // Load and cache ecosystem dependencies
  const deps = await loadEcosystemDependencies(ecosystem, context.projectRoot);
  
  if (!context.dependencyCache.has(ecosystem)) {
    context.dependencyCache.set(ecosystem, new Map());
  }
  
  // Cache all deps for this ecosystem
  for (const [name, version] of Object.entries(deps)) {
    context.dependencyCache.get(ecosystem)!.set(name, version);
  }
  
  return ok(packageName in deps);
}

/**
 * Load dependencies for a specific ecosystem
 */
async function loadEcosystemDependencies(
  ecosystem: PackageEcosystem,
  projectRoot: string
): Promise<Record<string, string | boolean>> {
  switch (ecosystem) {
    case 'npm':
      return loadNpmDependencies(projectRoot);
    case 'pip':
      return loadPipDependencies(projectRoot);
    case 'go':
      return loadGoDependencies(projectRoot);
    case 'cargo':
      return loadCargoDependencies(projectRoot);
    case 'composer':
      return loadComposerDependencies(projectRoot);
    case 'gem':
      return loadGemDependencies(projectRoot);
    case 'pub':
      return loadPubDependencies(projectRoot);
    case 'maven':
      return loadMavenDependencies(projectRoot);
    case 'gradle':
      return loadGradleDependencies(projectRoot);
    case 'nuget':
      return loadNugetDependencies(projectRoot);
    default:
      return {};
  }
}

/**
 * Load npm dependencies from package.json
 */
async function loadNpmDependencies(projectRoot: string): Promise<Record<string, string>> {
  const pkgPath = path.join(projectRoot, 'package.json');
  const result = await readJson<{
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
  }>(pkgPath);
  
  if (!result.ok) return {};
  
  return {
    ...result.value.dependencies,
    ...result.value.devDependencies,
  };
}

/**
 * Load pip dependencies from Python files
 */
async function loadPipDependencies(projectRoot: string): Promise<Record<string, string | boolean>> {
  const deps: Record<string, string | boolean> = {};
  
  // Try requirements.txt
  const reqPath = path.join(projectRoot, 'requirements.txt');
  if (await fileExists(reqPath)) {
    const content = await readFile(reqPath);
    if (content.ok) {
      // Parse requirements.txt format: package==version or package>=version
      const lines = content.value.split('\n');
      for (const line of lines) {
        const match = line.match(/^([a-zA-Z0-9_-]+)/);
        if (match) {
          deps[match[1].toLowerCase()] = true;
        }
      }
    }
  }
  
  // Try pyproject.toml (simplified parsing)
  const pyprojectPath = path.join(projectRoot, 'pyproject.toml');
  if (await fileExists(pyprojectPath)) {
    const content = await readFile(pyprojectPath);
    if (content.ok) {
      // Basic regex for dependencies section
      const depMatches = content.value.matchAll(/["']([a-zA-Z0-9_-]+)/g);
      for (const match of depMatches) {
        deps[match[1].toLowerCase()] = true;
      }
    }
  }
  
  return deps;
}

// Similar implementations for go, cargo, composer, gem, pub, maven, gradle, nuget...
// Each reads the appropriate config file(s) and extracts package names
```

#### 6.2.4 Main Evaluation Logic

```typescript
/**
 * Evaluate a single condition against project context
 */
async function evaluateSingleCondition(
  condition: ParsedCondition,
  context: ProjectContext
): Promise<Result<boolean, ConditionError>> {
  const { identifier, negated, operator, value } = condition;
  const { namespace, name } = identifier;
  
  let exists: boolean;
  let actualValue: string | number | boolean | undefined;
  
  // Handle each namespace type
  switch (namespace) {
    // Package ecosystems
    case 'npm':
    case 'pip':
    case 'go':
    case 'cargo':
    case 'composer':
    case 'gem':
    case 'pub':
    case 'maven':
    case 'gradle':
    case 'nuget': {
      const depResult = await checkDependency(namespace, name, context);
      if (!depResult.ok) return depResult;
      exists = depResult.value;
      break;
    }
    
    // File existence
    case 'file': {
      const filePath = path.join(context.projectRoot, name);
      exists = await fileExists(filePath);
      break;
    }
    
    // Directory existence
    case 'dir': {
      const dirPath = path.join(context.projectRoot, name);
      exists = await dirExists(dirPath);
      break;
    }
    
    // Package.json field
    case 'pkg': {
      if (!context.packageJson) {
        const pkgResult = await readJson(path.join(context.projectRoot, 'package.json'));
        context.packageJson = pkgResult.ok ? pkgResult.value as Record<string, unknown> : {};
      }
      actualValue = context.packageJson[name] as string | number | boolean | undefined;
      exists = actualValue !== undefined;
      break;
    }
    
    // User-defined variable
    case 'var': {
      actualValue = context.variables[name];
      exists = actualValue !== undefined;
      break;
    }
  }
  
  // Existence check (no operator)
  if (operator === null) {
    const result = exists;
    return ok(negated ? !result : result);
  }
  
  // Comparison check
  if (actualValue === undefined) {
    // Variable/field doesn't exist - comparison fails
    return ok(negated ? true : false);
  }
  
  let comparisonResult: boolean;
  switch (operator) {
    case '==':
      // eslint-disable-next-line eqeqeq
      comparisonResult = actualValue == value;
      break;
    case '!=':
      // eslint-disable-next-line eqeqeq
      comparisonResult = actualValue != value;
      break;
    case '>':
      comparisonResult = Number(actualValue) > Number(value);
      break;
    case '<':
      comparisonResult = Number(actualValue) < Number(value);
      break;
    case '>=':
      comparisonResult = Number(actualValue) >= Number(value);
      break;
    case '<=':
      comparisonResult = Number(actualValue) <= Number(value);
      break;
    default:
      comparisonResult = false;
  }
  
  return ok(negated ? !comparisonResult : comparisonResult);
}
```

### 6.3 Edge Cases to Handle

- [ ] Empty `when:` field → Include rule (no condition)
- [ ] Missing `when:` field → Include rule (no condition)
- [ ] Unknown namespace → Return `UNKNOWN_NAMESPACE` error
- [ ] Missing colon in identifier → Return `PARSE_ERROR`
- [ ] Scoped npm packages (`npm:@scope/pkg`) → Handle @ in name
- [ ] Go module paths with slashes → Handle full path as name
- [ ] File paths with spaces → Support quoted paths
- [ ] Ecosystem file missing (no package.json) → Dependency check returns false
- [ ] Multiple dependency files (requirements.txt + pyproject.toml) → Merge results
- [ ] Negation with comparison (`!pkg:type == "module"`) → Apply negation to result
- [ ] Case sensitivity → Package names case-sensitive, namespaces lowercase
- [ ] Whitespace in expressions → Trim and normalize
- [ ] Chained conditions with precedence → AND before OR
- [ ] Parse errors → Return descriptive error, don't crash

## 7. Test Requirements

### 7.1 Test File Structure

```typescript
// tests/unit/transformers/condition-evaluator.test.ts

describe('Condition Evaluator', () => {
  describe('parseIdentifier()', () => {
    it('should parse npm:package', () => { /* ... */ });
    it('should parse scoped npm:@scope/package', () => { /* ... */ });
    it('should parse file:path/to/file', () => { /* ... */ });
    it('should error on unknown namespace', () => { /* ... */ });
    it('should error on missing colon', () => { /* ... */ });
  });
  
  describe('parseConditionTerm()', () => {
    it('should parse existence check', () => { /* ... */ });
    it('should parse negated existence', () => { /* ... */ });
    it('should parse equality comparison', () => { /* ... */ });
    it('should parse quoted string values', () => { /* ... */ });
  });
  
  describe('evaluateCondition()', () => {
    describe('npm ecosystem', () => {
      it('should detect installed package', async () => { /* ... */ });
      it('should return false for missing package', async () => { /* ... */ });
      it('should handle scoped packages', async () => { /* ... */ });
    });
    
    describe('pip ecosystem', () => {
      it('should detect package in requirements.txt', async () => { /* ... */ });
      it('should detect package in pyproject.toml', async () => { /* ... */ });
    });
    
    describe('file/dir checks', () => {
      it('should detect existing file', async () => { /* ... */ });
      it('should return false for missing file', async () => { /* ... */ });
      it('should detect existing directory', async () => { /* ... */ });
    });
    
    describe('compound conditions', () => {
      it('should evaluate AND correctly', async () => { /* ... */ });
      it('should evaluate OR correctly', async () => { /* ... */ });
      it('should respect operator precedence', async () => { /* ... */ });
    });
  });
  
  describe('shouldIncludeRule()', () => {
    it('should return true for undefined when', () => { /* ... */ });
    it('should return true when condition matches', async () => { /* ... */ });
    it('should return false when condition fails', async () => { /* ... */ });
  });
});
```

### 7.2 Test Fixtures

```
tests/fixtures/conditional-rules/
├── package.json              # { "dependencies": { "react": "^18", "typescript": "^5" }}
├── requirements.txt          # django>=4.0\npytest
├── tsconfig.json             # Empty file for existence check
├── go.mod                    # module example.com/myapp\nrequire github.com/gin-gonic/gin v1.9.0
└── rules/
    ├── typescript-only.md    # when: npm:typescript
    ├── react-only.md         # when: npm:react
    ├── python-django.md      # when: pip:django
    └── always-applies.md     # No when field
```

## 8. Acceptance Criteria

- [ ] Parse namespaced identifiers (`npm:react`, `pip:django`, etc.)
- [ ] Support all 10 package ecosystems (npm, pip, go, cargo, composer, gem, pub, maven, gradle, nuget)
- [ ] Support `file:` and `dir:` checks
- [ ] Support `pkg:` for package.json field access
- [ ] Support `var:` for user-defined variables
- [ ] Support negation with `!` prefix
- [ ] Support `==` and `!=` operators for comparisons
- [ ] Support `&&` and `||` logical operators
- [ ] Cache dependency lookups per ecosystem
- [ ] All tests pass (`npm test -- condition-evaluator.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Exports added to `src/transformers/index.ts`
- [ ] `when` field added to Rule interface
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Parentheses for grouping (e.g., `(a || b) && c`) - future enhancement
- Semver version comparisons (`npm:react >= "18.0.0"`) - future enhancement
- Wildcard patterns in package names - future enhancement
- Remote file checks (URLs) - future enhancement
- Dynamic context refresh in watch mode - context built once per sync
- Full TOML/XML parsing - use regex for simple extraction

## 10. Implementation Checklist

1. [ ] Create `src/transformers/condition-evaluator.ts` with interfaces
2. [ ] Implement `parseIdentifier()` function
3. [ ] Implement `parseValue()` helper function
4. [ ] Implement `parseConditionTerm()` function
5. [ ] Implement `parseConditionExpression()` for compound conditions
6. [ ] Implement `loadNpmDependencies()` function
7. [ ] Implement `loadPipDependencies()` function
8. [ ] Implement dependency loaders for other ecosystems (stub implementations OK for MVP)
9. [ ] Implement `checkDependency()` with caching
10. [ ] Implement `evaluateSingleCondition()` function
11. [ ] Implement `evaluateConditionExpression()` main export
12. [ ] Implement `shouldIncludeRule()` helper export
13. [ ] Implement `buildProjectContext()` factory function
14. [ ] Export from `src/transformers/index.ts`
15. [ ] Add `when?: string` field to `Rule` interface in `src/parsers/rule.ts`
16. [ ] Create test fixtures in `tests/fixtures/conditional-rules/`
17. [ ] Add tests to `tests/unit/transformers/condition-evaluator.test.ts`
18. [ ] Run `npm test -- condition-evaluator.test.ts`
19. [ ] Run `npm run lint --fix`
20. [ ] Run `npm run typecheck`
21. [ ] Update plan.md with T226 completion status

## 11. Example Usage

### Node.js Project

```yaml
---
name: typescript-strict
description: Strict TypeScript guidelines
when: npm:typescript
globs:
  - "**/*.ts"
---

# TypeScript Strict Mode

These rules only apply when TypeScript is installed...
```

### React + TypeScript

```yaml
---
name: react-typescript-patterns
description: React with TypeScript best practices
when: npm:react && npm:typescript
---

# React TypeScript Patterns

Component patterns, hooks typing, etc...
```

### Testing Frameworks (OR)

```yaml
---
name: testing-patterns
description: Testing best practices
when: npm:jest || npm:vitest || npm:mocha
---

# Testing Patterns

Works with any major testing framework...
```

### Python Project

```yaml
---
name: django-guidelines
description: Django best practices
when: pip:django
---

# Django Guidelines

Models, views, templates patterns...
```

### Multi-Language Monorepo

```yaml
---
name: type-safety
description: Type safety guidelines
when: npm:typescript || pip:mypy || cargo:*
---

# Type Safety

Applies to typed languages...
```

### File-Based Condition

```yaml
---
name: docker-deployment
description: Docker deployment guidelines
when: file:Dockerfile && dir:.github/workflows
---

# Docker CI/CD

Container deployment patterns...
```

### Package.json Field Check

```yaml
---
name: esm-patterns
description: ES Modules patterns
when: pkg:type == "module"
---

# ES Modules

Import/export patterns for ESM projects...
```

### User-Defined Variables

```yaml
# config.yaml
context:
  is_monorepo: true
  environment: production
```

```yaml
---
name: monorepo-rules
description: Monorepo guidelines
when: var:is_monorepo
---

# Monorepo Guidelines

Workspace management, shared dependencies...
```

