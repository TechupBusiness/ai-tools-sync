# T210: Write Tests for Factory Features

> **Priority**: P1 | **Wave**: 2 | **Track**: D (Factory Platform)
> **Depends on**: T206, T207, T208, T209
> **Estimated complexity**: Medium

## 1. Objective

Create comprehensive tests for Factory platform features including droids generation with tool restrictions, hooks configuration, MCP config generation (stdio and http), and skills generation. These tests ensure feature parity with Cursor and Claude generators.

**Prerequisite Tasks Status:**
- T206 (Factory droids support) - Needs: `factory.tools`, `factory.model`, `factory.reasoningEffort`
- T207 (Factory hooks support) - Needs implementation (currently warns and skips)
- T208 (Factory MCP generation) - ✅ Already implemented (basic)
- T209 (Factory skills support) - ✅ Already implemented (basic)

**Note**: Some tests may need to be written against the expected interface before the features are implemented (TDD approach). This spec defines the expected behavior.

## 2. Prior Art (IMPORTANT)

Reference existing test implementations to copy patterns from:
- `tests/unit/generators/cursor.test.ts` - Test structure and helpers
- `tests/unit/generators/claude.test.ts` - Comprehensive hooks/settings tests
- `tests/unit/generators/factory.test.ts` - Existing Factory tests (extends this file)

## 3. File Structure

```
tests/
└── unit/
    └── generators/
        └── factory.test.ts   # Extend existing file with new describe blocks
```

## 4. Interfaces & Types

### Expected Factory Persona Extension (T206)

```typescript
// In src/parsers/types.ts - FactoryExtension
interface FactoryExtension {
  tools?: string[];           // Tool restrictions for Factory
  model?: string;             // Model override (e.g., 'gpt-4', 'claude-opus')
  reasoningEffort?: 'low' | 'medium' | 'high';  // Factory-specific reasoning control
}
```

### Expected Factory Hook Output (T207)

```typescript
// In src/generators/factory.ts
interface FactoryHookOutput {
  name: string;
  type?: 'command' | 'validation' | 'notification';
  command?: string;
  matcher?: string;           // Regex pattern for tool matching
  action?: 'warn' | 'block';
  message?: string;
}

// Factory settings.json structure
interface FactorySettings {
  hooks?: Record<FactoryHookEvent, FactoryHookOutput[]>;
}

type FactoryHookEvent =
  | 'PreToolUse'
  | 'PostToolUse'
  | 'UserPromptSubmit'
  | 'Notification'
  | 'Stop'
  | 'SubagentStop'
  | 'SessionStart'
  | 'SessionEnd'
  | 'PreCompact';
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use existing test helpers: `createMockContent`, `createMockRule`, `createMockPersona`, `createMockCommand`, `createMockHook`
- [x] Use temp directories for file system tests (`fs.mkdtemp`)
- [x] Clean up in `afterEach` blocks
- [x] Follow vitest patterns: `describe`, `it`, `expect`, `beforeEach`, `afterEach`
- [x] Test both dry run and actual file generation

### 5.2 Test Block Structure

```typescript
// Add these new describe blocks to factory.test.ts:

describe('generate() - droids with factory extensions', () => {
  // T206 tests
});

describe('generate() - hooks (Factory format)', () => {
  // T207 tests
});

describe('generate() - MCP (extended)', () => {
  // T208 additional tests
});

describe('generate() - skills (extended)', () => {
  // T209 additional tests
});
```

## 6. Test Requirements

### 6.1 T206: Droids with Tool Restrictions

```typescript
describe('generate() - droids with factory extensions', () => {
  it('should prefer factory.tools over base tools', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      personas: [
        createMockPersona('restricted-dev', {
          tools: ['read', 'write', 'edit', 'execute'],
          factory: {
            tools: ['read', 'edit'],  // More restricted
          },
        }),
      ],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/droids/restricted-dev.md'),
      'utf-8'
    );
    expect(fileContent).toContain('read');
    expect(fileContent).toContain('edit');
    expect(fileContent).not.toContain('write');
    expect(fileContent).not.toContain('execute');
  });

  it('should prefer factory.model over base model', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      personas: [
        createMockPersona('custom-model', {
          model: 'default',
          factory: {
            model: 'gpt-4-turbo',
          },
        }),
      ],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/droids/custom-model.md'),
      'utf-8'
    );
    expect(fileContent).toContain('gpt-4-turbo');
  });

  it('should include reasoningEffort when specified', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      personas: [
        createMockPersona('high-reasoning', {
          factory: {
            reasoningEffort: 'high',
          },
        }),
      ],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/droids/high-reasoning.md'),
      'utf-8'
    );
    expect(fileContent).toContain('**Reasoning Effort:** high');
  });

  it('should not include reasoningEffort when not specified', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      personas: [createMockPersona('default-reasoning')],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/droids/default-reasoning.md'),
      'utf-8'
    );
    expect(fileContent).not.toContain('Reasoning Effort');
  });

  it('should generate droid with all factory extensions', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      personas: [
        createMockPersona('full-factory', {
          description: 'Full factory configuration',
          factory: {
            tools: ['read', 'search'],
            model: 'claude-opus',
            reasoningEffort: 'medium',
          },
        }),
      ],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/droids/full-factory.md'),
      'utf-8'
    );
    expect(fileContent).toContain('# full-factory');
    expect(fileContent).toContain('> Full factory configuration');
    expect(fileContent).toContain('**Model:** claude-opus');
    expect(fileContent).toContain('**Tools:** read, search');
    expect(fileContent).toContain('**Reasoning Effort:** medium');
  });
});
```

### 6.2 T207: Hooks Configuration

```typescript
describe('generate() - hooks (Factory format)', () => {
  it('should generate settings file with hooks', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        createMockHook('format-on-edit', 'PostToolUse', ['factory']),
      ],
    });

    const result = await generator.generate(content);

    // Once implemented, should NOT warn
    expect(result.warnings.some(w => w.includes('does not support hooks'))).toBe(false);
    expect(result.files).toContain('.factory/settings.json');
  });

  it('should map generic events to Factory events', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        createMockHook('pre-tool', 'PreToolUse', ['factory']),
        createMockHook('post-tool', 'PostToolUse', ['factory']),
      ],
    });

    await generator.generate(content);

    const settingsContent = await fs.readFile(
      path.join(tempDir, '.factory/settings.json'),
      'utf-8'
    );
    const settings = JSON.parse(settingsContent);

    expect(settings.hooks.PreToolUse).toBeDefined();
    expect(settings.hooks.PostToolUse).toBeDefined();
  });

  it('should include matcher patterns for tool scoping', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        {
          frontmatter: {
            name: 'safety-check',
            event: 'PreToolUse',
            tool_match: 'Bash(*rm*)',
            execute: './scripts/safety.sh',
            targets: ['factory'],
          },
          content: '',
        },
      ],
    });

    await generator.generate(content);

    const settingsContent = await fs.readFile(
      path.join(tempDir, '.factory/settings.json'),
      'utf-8'
    );
    const settings = JSON.parse(settingsContent);

    expect(settings.hooks.PreToolUse[0].matcher).toBe('Bash(*rm*)');
    expect(settings.hooks.PreToolUse[0].command).toBe('./scripts/safety.sh');
  });

  it('should support action and message for blocking hooks', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        {
          frontmatter: {
            name: 'block-delete',
            event: 'PreToolUse',
            tool_match: 'Bash(*rm -rf*)',
            execute: 'false',
            targets: ['factory'],
            factory: {
              action: 'block',
              message: 'Recursive delete blocked',
            },
          },
          content: '',
        },
      ],
    });

    await generator.generate(content);

    const settingsContent = await fs.readFile(
      path.join(tempDir, '.factory/settings.json'),
      'utf-8'
    );
    const settings = JSON.parse(settingsContent);

    expect(settings.hooks.PreToolUse[0].action).toBe('block');
    expect(settings.hooks.PreToolUse[0].message).toBe('Recursive delete blocked');
  });

  it('should omit matcher when undefined or "*"', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        {
          frontmatter: {
            name: 'all-tools',
            event: 'PostToolUse',
            execute: 'echo done',
            targets: ['factory'],
          },
          content: '',
        },
      ],
    });

    await generator.generate(content);

    const settingsContent = await fs.readFile(
      path.join(tempDir, '.factory/settings.json'),
      'utf-8'
    );
    const settings = JSON.parse(settingsContent);

    expect(settings.hooks.PostToolUse[0].matcher).toBeUndefined();
  });

  it('should filter hooks not targeting factory', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      hooks: [
        createMockHook('factory-hook', 'PreToolUse', ['factory']),
        createMockHook('claude-hook', 'PreToolUse', ['claude']),
      ],
    });

    await generator.generate(content);

    const settingsContent = await fs.readFile(
      path.join(tempDir, '.factory/settings.json'),
      'utf-8'
    );
    const settings = JSON.parse(settingsContent);

    expect(settings.hooks.PreToolUse).toHaveLength(1);
  });
});
```

### 6.3 T208: MCP Configuration (Extended Tests)

```typescript
describe('generate() - MCP (extended)', () => {
  it('should support HTTP server type', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      mcpConfig: {
        servers: {
          remote: {
            url: 'https://api.example.com/mcp',
            headers: { 'X-API-Key': 'secret' },
            targets: ['factory'],
            enabled: true,
          },
        },
      },
    });

    const result = await generator.generate(content);

    expect(result.files).toContain('.factory/mcp.json');
    const mcpContent = await fs.readFile(
      path.join(tempDir, '.factory/mcp.json'),
      'utf-8'
    );
    const mcpJson = JSON.parse(mcpContent);

    expect(mcpJson.mcpServers.remote.url).toBe('https://api.example.com/mcp');
    expect(mcpJson.mcpServers.remote.headers['X-API-Key']).toBe('secret');
  });

  it('should include env and cwd for command servers', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      mcpConfig: {
        servers: {
          local: {
            command: 'node',
            args: ['server.js'],
            env: { DEBUG: 'true' },
            cwd: '/path/to/server',
            targets: ['factory'],
            enabled: true,
          },
        },
      },
    });

    await generator.generate(content);

    const mcpContent = await fs.readFile(
      path.join(tempDir, '.factory/mcp.json'),
      'utf-8'
    );
    const mcpJson = JSON.parse(mcpContent);

    expect(mcpJson.mcpServers.local.env.DEBUG).toBe('true');
    expect(mcpJson.mcpServers.local.cwd).toBe('/path/to/server');
  });

  it('should handle mixed stdio and http servers', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      mcpConfig: {
        servers: {
          local: {
            command: 'npx',
            args: ['mcp-server'],
            targets: ['factory'],
            enabled: true,
          },
          remote: {
            url: 'https://mcp.example.com',
            targets: ['factory'],
            enabled: true,
          },
        },
      },
    });

    await generator.generate(content);

    const mcpContent = await fs.readFile(
      path.join(tempDir, '.factory/mcp.json'),
      'utf-8'
    );
    const mcpJson = JSON.parse(mcpContent);

    expect(mcpJson.mcpServers.local.command).toBe('npx');
    expect(mcpJson.mcpServers.remote.url).toBe('https://mcp.example.com');
  });

  it('should exclude disabled servers', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      mcpConfig: {
        servers: {
          enabled: { command: 'server', targets: ['factory'], enabled: true },
          disabled: { command: 'other', targets: ['factory'], enabled: false },
        },
      },
    });

    await generator.generate(content);

    const mcpContent = await fs.readFile(
      path.join(tempDir, '.factory/mcp.json'),
      'utf-8'
    );
    const mcpJson = JSON.parse(mcpContent);

    expect(mcpJson.mcpServers.enabled).toBeDefined();
    expect(mcpJson.mcpServers.disabled).toBeUndefined();
  });
});
```

### 6.4 T209: Skills (Extended Tests)

```typescript
describe('generate() - skills (extended)', () => {
  it('should include priority in metadata when not medium', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      rules: [createMockRule('high-priority', { priority: 'high' })],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/skills/high-priority/SKILL.md'),
      'utf-8'
    );
    expect(fileContent).toContain('**Priority:** high');
  });

  it('should include requires in metadata', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      rules: [createMockRule('dependent', { requires: ['core', 'database'] })],
    });

    await generator.generate(content);

    const fileContent = await fs.readFile(
      path.join(tempDir, '.factory/skills/dependent/SKILL.md'),
      'utf-8'
    );
    expect(fileContent).toContain('**Requires:** core, database');
  });

  it('should list always_apply skills in Required Skills section of AGENTS.md', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      rules: [
        createMockRule('core', { always_apply: true }),
        createMockRule('optional', { always_apply: false }),
      ],
    });

    await generator.generate(content);

    const agentsContent = await fs.readFile(
      path.join(tempDir, 'AGENTS.md'),
      'utf-8'
    );
    expect(agentsContent).toContain('## Required Skills');
    expect(agentsContent).toContain('core');
    expect(agentsContent).toContain('## Available Skills');
    expect(agentsContent).toContain('optional');
  });

  it('should sort skills by priority in AGENTS.md', async () => {
    const content = createMockContent({
      projectRoot: tempDir,
      rules: [
        createMockRule('low', { priority: 'low' }),
        createMockRule('high', { priority: 'high' }),
        createMockRule('medium', { priority: 'medium' }),
      ],
    });

    const result = await generator.generate(content, { dryRun: true });

    const skillFiles = result.generated?.filter((f) => f.type === 'rule') ?? [];
    expect(skillFiles[0]?.path).toContain('high');
    expect(skillFiles[1]?.path).toContain('medium');
    expect(skillFiles[2]?.path).toContain('low');
  });
});
```

## 7. Integration Points

- **Imports from**: 
  - `src/generators/factory.ts` - `FactoryGenerator`, `createFactoryGenerator`
  - `src/generators/base.ts` - `ResolvedContent`
  - `src/parsers/*` - `ParsedRule`, `ParsedPersona`, `ParsedCommand`, `ParsedHook`

- **Tests**: `tests/unit/generators/factory.test.ts`

## 8. Acceptance Criteria

- [x] All new tests for T206 (droids) pass
- [x] All new tests for T207 (hooks) pass
- [x] All new tests for T208 (MCP type field) pass
- [x] All new tests for T209 (skills extended) pass
- [x] Existing Factory tests still pass
- [x] No lint errors (`npm run lint`)
- [x] Test coverage for Factory generator ≥ 90% (actual: 93.86%)

### Progress Notes (2025-12-08)
- Added new describe blocks for droids, hooks, MCP, and skills in `tests/unit/generators/factory.test.ts`.
- T207 (hooks) tests pass - hooks are implemented.
- T208 tests added and pass: `type: "stdio"` for command servers, `type: "http"` for URL servers, no experimental warning.
- All 51 factory tests pass.
- Lint passes, coverage at 93.86%.

## 9. Out of Scope

- Implementing the actual features (T206, T207) - only tests
- Claude generator tests (already comprehensive)
- Cursor generator tests (already comprehensive)

## 10. Implementation Notes

### Test-First Approach

Since T206 and T207 may not be fully implemented yet, these tests serve as:
1. **Specification** - Define expected behavior
2. **Acceptance criteria** - Tests must pass when features are done
3. **Regression protection** - Prevent breaking changes

### Helper Function Updates

May need to update `createMockPersona` and `createMockHook` helpers to support factory extensions:

```typescript
// Updated helper for personas with factory extension
function createMockPersona(
  name: string, 
  overrides: Partial<ParsedPersona['frontmatter']> & { 
    factory?: FactoryExtension 
  } = {}
): ParsedPersona {
  const { factory, ...frontmatterOverrides } = overrides;
  
  const frontmatter: ParsedPersona['frontmatter'] = {
    name,
    tools: ['read', 'write', 'edit'],
    model: 'default',
    targets: ['cursor', 'claude', 'factory'],
    ...frontmatterOverrides,
  };
  
  if (factory) {
    frontmatter.factory = factory;
  }
  
  return {
    frontmatter,
    content: `# ${name}\n\nThis is the ${name} persona.`,
  };
}
```

### Tests May Initially Fail

If features aren't implemented:
- Mark tests with `.skip` or `.todo` temporarily
- Document expected behavior in test descriptions
- Enable tests as features are completed

