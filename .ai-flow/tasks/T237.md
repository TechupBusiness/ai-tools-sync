# T237: Implement File Content Variables

> **Priority**: P2 | **Wave**: 9 | **Track**: E (Custom Variables)
> **Depends on**: T236 (Custom Variable Providers)
> **Estimated complexity**: Low

## 1. Objective

Add support for inline file content variables using `{{file:path}}` syntax. This complements the `@include` directive (T225) for cases where you want to embed a small snippet inline rather than include an entire file.

## 2. Use Cases

| Use Case | `@include` | `{{file:...}}` |
|----------|------------|----------------|
| Full file inclusion | ✅ Best choice | ❌ Not ideal |
| Inline version number | ❌ Overkill | ✅ Best choice |
| Code snippet in paragraph | ❌ Adds newlines | ✅ Inline |
| Shared documentation section | ✅ Best choice | ❌ Not ideal |

### Examples

```markdown
<!-- Inline version from file -->
Current version: {{file:VERSION}}

<!-- Specific lines from a file -->
License header:
{{file:LICENSE:1-5}}

<!-- Code example inline -->
The default config is: `{{file:defaults.json}}`
```

## 3. Syntax Design

### 3.1 Basic Syntax

```
{{file:relative/path/to/file}}
```

- Path is relative to project root (or current file's directory - TBD)
- Entire file content is inlined
- Trailing newlines are stripped
- Max content length enforced (default: 10KB)

### 3.2 Line Range Syntax

```
{{file:path/to/file:START-END}}
{{file:path/to/file:LINE}}
```

- `{{file:LICENSE:1-5}}` - Lines 1 through 5 (inclusive)
- `{{file:config.json:10}}` - Only line 10
- `{{file:log.txt:-5}}` - Last 5 lines
- Lines are 1-indexed (like editors)

### 3.3 Syntax Differentiation

The `file:` prefix distinguishes from regular variables:

| Syntax | Type | Handler |
|--------|------|---------|
| `{{project_name}}` | Built-in variable | T229 |
| `{{custom_var}}` | Custom variable | T236 |
| `{{file:VERSION}}` | File content | T237 |

## 4. Implementation

### 4.1 Pattern Matching

```typescript
// In template-variables.ts

// Match {{file:path}} or {{file:path:lines}}
const FILE_VARIABLE_PATTERN = /\{\{file:([^}:]+)(?::([^}]+))?\}\}/g;

// Examples:
// {{file:VERSION}} → path="VERSION", lines=undefined
// {{file:src/config.ts:1-10}} → path="src/config.ts", lines="1-10"
// {{file:log.txt:-5}} → path="log.txt", lines="-5"
```

### 4.2 File Content Resolution

```typescript
interface FileVariableOptions {
  /** Project root for resolving relative paths */
  projectRoot: string;
  /** Maximum content length in bytes (default: 10240) */
  maxLength?: number;
  /** Base directory for relative paths (default: projectRoot) */
  baseDir?: string;
}

/**
 * Resolve a file variable to its content
 */
async function resolveFileVariable(
  filePath: string,
  lineSpec: string | undefined,
  options: FileVariableOptions
): Promise<string | undefined> {
  const { projectRoot, maxLength = 10240, baseDir = projectRoot } = options;

  // Resolve path relative to baseDir
  const absolutePath = path.resolve(baseDir, filePath);

  // Security: Ensure path is within project
  if (!absolutePath.startsWith(projectRoot)) {
    console.warn(`File variable path must be within project: ${filePath}`);
    return undefined;
  }

  // Read file
  const result = await readFile(absolutePath);
  if (!result.ok) {
    console.warn(`File variable not found: ${filePath}`);
    return undefined;
  }

  let content = result.value;

  // Apply line range if specified
  if (lineSpec) {
    content = extractLines(content, lineSpec);
  }

  // Enforce max length
  if (content.length > maxLength) {
    console.warn(`File content truncated: ${filePath} (${content.length} > ${maxLength})`);
    content = content.slice(0, maxLength) + '...';
  }

  // Strip trailing newlines for inline use
  return content.trimEnd();
}

/**
 * Extract lines based on line spec
 */
function extractLines(content: string, lineSpec: string): string {
  const lines = content.split('\n');

  // Single line: "10"
  if (/^\d+$/.test(lineSpec)) {
    const lineNum = parseInt(lineSpec, 10);
    return lines[lineNum - 1] ?? '';
  }

  // Last N lines: "-5"
  if (/^-\d+$/.test(lineSpec)) {
    const count = parseInt(lineSpec.slice(1), 10);
    return lines.slice(-count).join('\n');
  }

  // Range: "1-10"
  const rangeMatch = lineSpec.match(/^(\d+)-(\d+)$/);
  if (rangeMatch) {
    const start = parseInt(rangeMatch[1], 10);
    const end = parseInt(rangeMatch[2], 10);
    return lines.slice(start - 1, end).join('\n');
  }

  console.warn(`Invalid line spec: ${lineSpec}`);
  return content;
}
```

### 4.3 Integration in Transform Function

```typescript
export async function transformTemplateVariables(
  content: string,
  context: TemplateVariableContext = {},
  options: TemplateVariableOptions = {}
): Promise<string> {
  const { unknownVariables = 'preserve' } = options;
  const projectRoot = context.projectRoot ?? process.cwd();

  // Skip if no variables in content (optimization)
  if (!content.includes('{{')) {
    return content;
  }

  // 1. First pass: Resolve file variables (before regular variables)
  content = await resolveFileVariables(content, { projectRoot });

  // 2. Second pass: Resolve regular variables
  const resolved = await resolveVariables(context);

  const VARIABLE_PATTERN = /\{\{(?!#|\/|!|file:)([a-z][a-z0-9_]*)\}\}/g;

  return content.replace(VARIABLE_PATTERN, (match, varName: string) => {
    const value = resolved[varName];
    if (value !== undefined) {
      return value;
    }
    return unknownVariables === 'remove' ? '' : match;
  });
}

/**
 * Resolve all {{file:...}} variables in content
 */
async function resolveFileVariables(
  content: string,
  options: FileVariableOptions
): Promise<string> {
  const FILE_VARIABLE_PATTERN = /\{\{file:([^}:]+)(?::([^}]+))?\}\}/g;

  // Collect all matches first (can't use async in replace)
  const matches: Array<{
    full: string;
    path: string;
    lines?: string;
    index: number;
  }> = [];

  let match;
  while ((match = FILE_VARIABLE_PATTERN.exec(content)) !== null) {
    matches.push({
      full: match[0],
      path: match[1],
      lines: match[2],
      index: match.index,
    });
  }

  // Resolve all file contents
  const resolutions = await Promise.all(
    matches.map(async (m) => ({
      ...m,
      content: await resolveFileVariable(m.path, m.lines, options),
    }))
  );

  // Replace in reverse order to preserve indices
  let result = content;
  for (const r of resolutions.reverse()) {
    if (r.content !== undefined) {
      result = result.slice(0, r.index) + r.content + result.slice(r.index + r.full.length);
    }
  }

  return result;
}
```

## 5. Test Requirements

```typescript
describe('file content variables', () => {
  const fixtureDir = path.join(__dirname, '../../fixtures/file-vars');

  beforeAll(() => {
    // Create fixture files
    fs.mkdirSync(fixtureDir, { recursive: true });
    fs.writeFileSync(path.join(fixtureDir, 'VERSION'), '1.2.3\n');
    fs.writeFileSync(path.join(fixtureDir, 'multiline.txt'), 'line1\nline2\nline3\nline4\nline5\n');
    fs.writeFileSync(path.join(fixtureDir, 'config.json'), '{"key": "value"}');
  });

  it('should resolve simple file variable', async () => {
    const content = 'Version: {{file:VERSION}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('Version: 1.2.3');
  });

  it('should resolve file with line range', async () => {
    const content = '{{file:multiline.txt:2-4}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('line2\nline3\nline4');
  });

  it('should resolve single line', async () => {
    const content = '{{file:multiline.txt:3}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('line3');
  });

  it('should resolve last N lines', async () => {
    const content = '{{file:multiline.txt:-2}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('line4\nline5');
  });

  it('should strip trailing newlines', async () => {
    const content = '{{file:VERSION}} is current';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('1.2.3 is current');
  });

  it('should preserve missing file variable', async () => {
    const content = '{{file:nonexistent.txt}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('{{file:nonexistent.txt}}');
  });

  it('should reject paths outside project', async () => {
    const content = '{{file:../../../etc/passwd}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
    });
    expect(result).toBe('{{file:../../../etc/passwd}}');
  });

  it('should work with regular variables', async () => {
    const content = '{{project_name}} v{{file:VERSION}}';
    const result = await transformTemplateVariables(content, {
      projectRoot: fixtureDir,
      config: { project_name: 'MyApp' },
    });
    expect(result).toBe('MyApp v1.2.3');
  });
});
```

## 6. Acceptance Criteria

- [ ] `{{file:path}}` resolves file content inline
- [ ] `{{file:path:N}}` extracts single line
- [ ] `{{file:path:N-M}}` extracts line range
- [ ] `{{file:path:-N}}` extracts last N lines
- [ ] Trailing newlines stripped
- [ ] Missing files preserved as placeholder
- [ ] Path traversal prevented (must be within project)
- [ ] Max length enforced with truncation warning
- [ ] Works alongside regular variables
- [ ] All tests pass
- [ ] No lint errors

## 7. Out of Scope

- Binary file handling
- Glob patterns in file path
- Remote/URL file sources
- File watching/caching
- Encoding options (UTF-8 only)

## 8. Comparison: `@include` vs `{{file:...}}`

| Feature | `@include path.md` | `{{file:path}}` |
|---------|-------------------|-----------------|
| **Location** | Own line only | Inline anywhere |
| **Frontmatter** | Stripped | Included as-is |
| **Nested includes** | ✅ Supported | ❌ Not supported |
| **Line ranges** | ❌ Whole file | ✅ Supported |
| **Best for** | Documentation sections | Version numbers, snippets |
| **Newline handling** | Preserves | Strips trailing |

Both features complement each other for different use cases.
