# T223: Implement Per-Tool-Folder Gitignores

> **Priority**: P2 | **Wave**: 5 | **Track**: A (Per-Tool Gitignores)
> **Depends on**: T188-T190 ✅ (manifest + gitignore management)
> **Estimated complexity**: Low

## 1. Objective

Implement distributed `.gitignore` files within each tool folder (`.cursor/.gitignore`, `.claude/.gitignore`, `.factory/.gitignore`) instead of listing all paths in the root `.gitignore`. Each tool-folder gitignore uses the same auto-managed section pattern (preserving user additions) but contains only relative paths within that specific folder. This improves organization by keeping tool-specific ignores co-located with the tools themselves and simplifies the root `.gitignore`.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/utils/gitignore.ts` - **Exact pattern to reuse**: `updateGitignoreContent()`, `createManagedSection()`, `hasManagedSection()`, markers
- `src/cli/commands/sync.ts` - **Lines 499-525**: Current gitignore update flow in `generateManifestAndGitignore()`
- `src/generators/cursor.ts` - **Generator output path patterns** (`.cursor/rules/`, `.cursor/commands/`)
- `src/generators/claude.ts` - **Generator output path patterns** (`.claude/skills/`, `.claude/agents/`)
- `src/generators/factory.ts` - **Generator output path patterns** (`.factory/skills/`, `.factory/droids/`)
- `tests/unit/utils/gitignore.test.ts` - **Test patterns** for gitignore utilities

## 3. File Structure

```
src/
├── utils/
│   ├── gitignore.ts          # Extend with updateToolFolderGitignore()
│   └── index.ts              # Export new function
├── cli/
│   └── commands/
│       └── sync.ts           # Call new function after generation
tests/
└── unit/
    └── utils/
        └── gitignore.test.ts # Add tests for per-folder gitignores
```

## 4. Interfaces & Types

### 4.1 New Function Signature

```typescript
// In src/utils/gitignore.ts

/**
 * Tool folder configuration for gitignore generation
 */
export interface ToolFolderGitignoreConfig {
  /** Tool folder path relative to project root (e.g., '.cursor') */
  folder: string;
  /** Relative paths within the folder to ignore (e.g., ['rules/', 'commands/']) */
  paths: string[];
}

/**
 * Result of updating tool folder gitignores
 */
export interface ToolFolderGitignoreResult {
  /** Tool folder path */
  folder: string;
  /** Whether gitignore was created (vs updated) */
  created: boolean;
  /** Whether any changes were made */
  changed: boolean;
  /** Paths added to the managed section */
  paths: string[];
}

/**
 * Options for updating tool folder gitignores
 */
export interface UpdateToolFolderGitignoreOptions {
  /** Whether to create .gitignore if it doesn't exist (default: true) */
  createIfMissing?: boolean;
  /** Dry run mode - don't write files */
  dryRun?: boolean;
}
```

### 4.2 Updated Manifest Types

```typescript
// No new types needed - uses existing Manifest types from src/utils/manifest.ts
// The manifest already tracks files per directory which can be grouped by tool folder
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [ ] Use `Result<T, E>` for error handling (see `src/utils/result.ts`)
- [ ] Reuse `updateGitignoreContent()`, `createManagedSection()` from existing gitignore.ts
- [ ] Use same markers: `GITIGNORE_START_MARKER`, `GITIGNORE_END_MARKER`
- [ ] Use `fileExists`, `readFile`, `writeFile`, `ensureDir` from `src/utils/fs.ts`
- [ ] Export from `src/utils/index.ts`
- [ ] No `any` types
- [ ] Run `npm run lint --fix` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Extract Relative Paths Within Tool Folder

```typescript
// ❌ WRONG - Keeping full path in tool folder gitignore
// .cursor/.gitignore would contain: .cursor/rules/core.mdc
paths.push('.cursor/rules/core.mdc');

// ✅ CORRECT - Use relative path from tool folder
// .cursor/.gitignore should contain: rules/core.mdc
function getRelativePathInFolder(fullPath: string, folder: string): string | null {
  if (!fullPath.startsWith(folder + '/')) {
    return null; // Not in this folder
  }
  return fullPath.slice(folder.length + 1); // +1 for the slash
}
```

#### 5.2.2 Group Files by Tool Folder

```typescript
// ✅ CORRECT - Group manifest files by tool folder
function groupFilesByToolFolder(
  files: string[],
  toolFolders: string[]
): Map<string, string[]> {
  const groups = new Map<string, string[]>();
  
  // Initialize all folders with empty arrays
  for (const folder of toolFolders) {
    groups.set(folder, []);
  }
  
  for (const file of files) {
    for (const folder of toolFolders) {
      if (file.startsWith(folder + '/')) {
        const relativePath = file.slice(folder.length + 1);
        groups.get(folder)!.push(relativePath);
        break; // File belongs to first matching folder only
      }
    }
  }
  
  return groups;
}
```

#### 5.2.3 Main Update Function

```typescript
/**
 * Update gitignore files in each tool folder
 */
export async function updateToolFolderGitignores(
  projectRoot: string,
  manifest: Manifest | null,
  options: UpdateToolFolderGitignoreOptions = {}
): Promise<Result<ToolFolderGitignoreResult[]>> {
  const toolFolders = ['.cursor', '.claude', '.factory'];
  const results: ToolFolderGitignoreResult[] = [];

  // Get all file paths from manifest or use defaults
  const allPaths = manifest
    ? [...manifest.files, ...manifest.directories]
    : getDefaultGitignorePaths();

  // Group paths by tool folder
  const grouped = groupFilesByToolFolder(allPaths, toolFolders);

  for (const [folder, paths] of grouped.entries()) {
    // Skip folders with no generated content
    if (paths.length === 0) {
      continue;
    }

    const gitignorePath = path.join(projectRoot, folder, '.gitignore');
    const folderPath = path.join(projectRoot, folder);

    // Check if folder exists (skip if no content generated for this target)
    if (!(await fileExists(folderPath))) {
      continue;
    }

    // Prepare unique paths (directories should end with /)
    const uniquePaths = [...new Set(paths)].sort();

    // Update or create the gitignore
    const result = await updateGitignoreInFolder(
      gitignorePath,
      uniquePaths,
      options
    );

    if (!result.ok) {
      return err(result.error);
    }

    results.push({
      folder,
      ...result.value,
      paths: uniquePaths,
    });
  }

  return ok(results);
}

/**
 * Update gitignore within a specific folder
 */
async function updateGitignoreInFolder(
  gitignorePath: string,
  paths: string[],
  options: UpdateToolFolderGitignoreOptions
): Promise<Result<{ created: boolean; changed: boolean }>> {
  const exists = await fileExists(gitignorePath);

  if (!exists) {
    if (options.createIfMissing === false) {
      return ok({ created: false, changed: false });
    }

    if (options.dryRun) {
      return ok({ created: true, changed: true });
    }

    // Create new gitignore with managed section
    const content = createManagedSection(paths) + '\n';
    const result = await writeFile(gitignorePath, content);
    if (!result.ok) {
      return err(result.error);
    }
    return ok({ created: true, changed: true });
  }

  // Read existing content
  const existingResult = await readFile(gitignorePath);
  if (!existingResult.ok) {
    return err(existingResult.error);
  }

  const existingContent = existingResult.value;
  const newContent = updateGitignoreContent(existingContent, paths);

  // Check if content changed
  if (existingContent === newContent) {
    return ok({ created: false, changed: false });
  }

  if (options.dryRun) {
    return ok({ created: false, changed: true });
  }

  // Write updated content
  const writeResult = await writeFile(gitignorePath, newContent);
  if (!writeResult.ok) {
    return err(writeResult.error);
  }

  return ok({ created: false, changed: true });
}
```

### 5.3 Edge Cases to Handle

- [ ] Tool folder doesn't exist (not in targets) → Skip silently
- [ ] No files in a tool folder → Skip that folder's gitignore
- [ ] Existing user content in tool folder gitignore → Preserve it (managed section pattern)
- [ ] Manifest is null → Use default paths and group them
- [ ] Mixed file and directory paths → Both are valid gitignore entries
- [ ] Path already exists in gitignore outside managed section → Don't duplicate
- [ ] Tool folder gitignore exists but is empty → Append managed section
- [ ] Dry run mode → Don't write files, just report what would change

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/utils/gitignore.test.ts - ADD to existing file

describe('Tool Folder Gitignores', () => {
  describe('groupFilesByToolFolder', () => {
    it('should group files by their tool folder', () => { /* ... */ });
    it('should handle files not in any tool folder', () => { /* ... */ });
    it('should handle nested paths within tool folders', () => { /* ... */ });
  });

  describe('updateToolFolderGitignores', () => {
    describe('with manifest', () => {
      it('should create gitignores for folders with content', async () => { /* ... */ });
      it('should skip folders with no generated content', async () => { /* ... */ });
      it('should use relative paths within each folder', async () => { /* ... */ });
    });

    describe('without manifest', () => {
      it('should use default paths', async () => { /* ... */ });
    });

    describe('preserving user content', () => {
      it('should preserve existing content outside managed section', async () => { /* ... */ });
      it('should update managed section while keeping user content', async () => { /* ... */ });
    });

    describe('dry run', () => {
      it('should not write files in dry run mode', async () => { /* ... */ });
      it('should report what would be created', async () => { /* ... */ });
    });
  });
});
```

### 6.2 Required Test Cases

```typescript
// Test: Creates tool folder gitignores with relative paths
it('should create gitignores with relative paths', async () => {
  // Setup: Create tool folders
  await fs.mkdir(path.join(testDir, '.cursor', 'rules'), { recursive: true });
  await fs.mkdir(path.join(testDir, '.claude', 'skills'), { recursive: true });

  const manifest: Manifest = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: [
      '.cursor/rules/core.mdc',
      '.cursor/rules/database.mdc',
      '.cursor/commands/deploy.md',
      '.claude/skills/test/SKILL.md',
      'CLAUDE.md', // Root file - not in any tool folder
    ],
    directories: ['.cursor/rules/', '.claude/skills/'],
  };

  const result = await updateToolFolderGitignores(testDir, manifest);

  expect(result.ok).toBe(true);
  
  // Check .cursor/.gitignore
  const cursorGitignore = await readFile(path.join(testDir, '.cursor', '.gitignore'));
  expect(cursorGitignore.ok).toBe(true);
  expect(cursorGitignore.value).toContain('rules/core.mdc');
  expect(cursorGitignore.value).toContain('rules/database.mdc');
  expect(cursorGitignore.value).toContain('commands/deploy.md');
  expect(cursorGitignore.value).not.toContain('.cursor/'); // Should be relative, not absolute
  
  // Check .claude/.gitignore
  const claudeGitignore = await readFile(path.join(testDir, '.claude', '.gitignore'));
  expect(claudeGitignore.ok).toBe(true);
  expect(claudeGitignore.value).toContain('skills/test/SKILL.md');
  
  // .factory/.gitignore should not be created (folder doesn't exist)
  expect(await fileExists(path.join(testDir, '.factory', '.gitignore'))).toBe(false);
});

// Test: Preserves user content
it('should preserve existing user content', async () => {
  await fs.mkdir(path.join(testDir, '.cursor'), { recursive: true });
  
  // Create existing gitignore with user content
  await fs.writeFile(
    path.join(testDir, '.cursor', '.gitignore'),
    `# My custom ignores
*.log
temp/

# Some other stuff
.DS_Store
`
  );

  const manifest: Manifest = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: ['.cursor/rules/core.mdc'],
    directories: ['.cursor/rules/'],
  };

  await updateToolFolderGitignores(testDir, manifest);

  const content = await readFile(path.join(testDir, '.cursor', '.gitignore'));
  expect(content.ok).toBe(true);
  
  // User content preserved
  expect(content.value).toContain('# My custom ignores');
  expect(content.value).toContain('*.log');
  expect(content.value).toContain('temp/');
  expect(content.value).toContain('.DS_Store');
  
  // Managed section added
  expect(content.value).toContain(GITIGNORE_START_MARKER);
  expect(content.value).toContain('rules/core.mdc');
  expect(content.value).toContain(GITIGNORE_END_MARKER);
});

// Test: Updates managed section
it('should update managed section on re-run', async () => {
  await fs.mkdir(path.join(testDir, '.cursor', 'rules'), { recursive: true });
  
  // First run with initial content
  const manifest1: Manifest = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: ['.cursor/rules/old.mdc'],
    directories: ['.cursor/rules/'],
  };
  await updateToolFolderGitignores(testDir, manifest1);
  
  // Second run with different content
  const manifest2: Manifest = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: ['.cursor/rules/new.mdc', '.cursor/rules/another.mdc'],
    directories: ['.cursor/rules/'],
  };
  await updateToolFolderGitignores(testDir, manifest2);
  
  const content = await readFile(path.join(testDir, '.cursor', '.gitignore'));
  expect(content.ok).toBe(true);
  
  // Old content should be gone
  expect(content.value).not.toContain('old.mdc');
  
  // New content should be present
  expect(content.value).toContain('rules/new.mdc');
  expect(content.value).toContain('rules/another.mdc');
  
  // Should only have one managed section
  const startCount = (content.value!.match(new RegExp(GITIGNORE_START_MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
  expect(startCount).toBe(1);
});
```

## 7. Integration Points

- **Imports from**:
  - `src/utils/fs.ts` - `fileExists`, `readFile`, `writeFile`
  - `src/utils/result.ts` - `Result`, `ok`, `err`
  - `src/utils/gitignore.ts` - `updateGitignoreContent`, `createManagedSection`, markers

- **Exports to**:
  - `src/cli/commands/sync.ts` - uses `updateToolFolderGitignores()` after generation

- **Integration in sync.ts**:
  ```typescript
  // In generateManifestAndGitignore() after existing gitignore update
  
  // Update tool-folder gitignores
  const toolFolderResult = await updateToolFolderGitignores(
    config.projectRoot,
    manifestForGitignore,
    { dryRun: options.dryRun }
  );
  
  if (toolFolderResult.ok) {
    for (const folderResult of toolFolderResult.value) {
      if (folderResult.changed) {
        printSuccess(`${folderResult.folder}/.gitignore updated`);
      }
    }
  } else {
    result.warnings.push(`Failed to update tool folder gitignores: ${toolFolderResult.error.message}`);
  }
  ```

- **Config**: No schema changes needed; will be opt-in in T224 via `distributed_gitignore: true`

## 8. Acceptance Criteria

- [ ] `updateToolFolderGitignores()` creates `.cursor/.gitignore`, `.claude/.gitignore`, `.factory/.gitignore` as needed
- [ ] Each gitignore contains only relative paths within that folder (not `.cursor/rules/` but `rules/`)
- [ ] Existing user content in tool folder gitignores is preserved
- [ ] Folders without generated content are skipped
- [ ] Dry run mode reports changes without writing
- [ ] All tests pass (`npm test -- gitignore.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Functions exported from `src/utils/index.ts`
- [ ] Integration added to `src/cli/commands/sync.ts`
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Configuration option to enable/disable distributed gitignores (T224)
- Simplifying root gitignore to only contain non-tool-folder files (T224)
- Removing tool folder paths from root gitignore when distributed mode is enabled (T224)
- Migration from current single-gitignore to distributed gitignores (future task)

## 10. Implementation Checklist

1. [ ] Add `ToolFolderGitignoreConfig`, `ToolFolderGitignoreResult`, `UpdateToolFolderGitignoreOptions` interfaces to `src/utils/gitignore.ts`
2. [ ] Add `groupFilesByToolFolder()` helper function
3. [ ] Add `updateGitignoreInFolder()` internal function (reuses existing utilities)
4. [ ] Add `updateToolFolderGitignores()` main export function
5. [ ] Export new function from `src/utils/index.ts`
6. [ ] Integrate into `src/cli/commands/sync.ts` in `generateManifestAndGitignore()`
7. [ ] Add tests to `tests/unit/utils/gitignore.test.ts`
8. [ ] Run `npm test -- gitignore.test.ts`
9. [ ] Run `npm run lint --fix`
10. [ ] Run `npm run typecheck`
11. [ ] Update plan.md with T223 completion status

## 11. Example Output

After running `ai-sync` with distributed gitignores, the project structure would look like:

```
project/
├── .gitignore                    # Root gitignore (only root-level generated files)
├── .cursor/
│   ├── .gitignore                # Auto-managed: rules/, commands/, hooks.json
│   ├── rules/
│   │   ├── core.mdc
│   │   └── database.mdc
│   └── commands/
│       └── deploy.md
├── .claude/
│   ├── .gitignore                # Auto-managed: skills/, agents/, commands/, settings.json
│   ├── skills/
│   │   └── typescript/SKILL.md
│   └── agents/
│       └── implementer.md
└── .factory/
    ├── .gitignore                # Auto-managed: skills/, droids/, commands/, mcp.json
    ├── skills/
    │   └── testing/SKILL.md
    └── droids/
        └── implementer.md
```

Each `.gitignore` uses the managed section:

```gitignore
# .cursor/.gitignore
# User additions can go here (preserved)

# >>> AI Tool Sync Generated (auto-managed) >>>
commands/
hooks.json
rules/
# <<< AI Tool Sync Generated <<<
```

