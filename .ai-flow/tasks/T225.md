# T225: Implement Import/Include Syntax in Rules

> **Priority**: P2 | **Wave**: 6 | **Track**: A (Rule Composition)
> **Depends on**: T040-T046 ✅ (parsers complete)
> **Estimated complexity**: Medium

## 1. Objective

Implement an `@include` directive that allows rules to import content from other markdown files. This enables content reuse across rules without duplication—for example, a base set of coding standards that multiple domain-specific rules can reference. Includes are resolved relative to the rule file's location and support nested includes with circular dependency detection.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/parsers/rule.ts` - **Lines 268-312**: `parseRule()` pattern for parsing with Result type
- `src/parsers/frontmatter.ts` - **Lines 120-179**: `parseFrontmatter()` for content parsing
- `src/utils/fs.ts` - **Lines 40-45, 173-178**: `readFile()`, `resolvePath()` for file operations
- `src/utils/result.ts` - **Lines 106-114**: `andThen()` for chaining Result operations
- `src/transformers/glob-matcher.ts` - Pattern for transformer module structure
- `tests/unit/parsers/rule.test.ts` - Test patterns for parser modules

## 3. File Structure

```
src/
├── transformers/
│   ├── include-resolver.ts    # Main implementation
│   └── index.ts               # Add export
tests/
├── unit/
│   └── transformers/
│       └── include-resolver.test.ts  # Unit tests
└── fixtures/
    └── includes/                      # Test fixtures
        ├── base.md
        ├── with-include.md
        ├── nested-a.md
        ├── nested-b.md
        ├── circular-a.md
        └── circular-b.md
```

## 4. Interfaces & Types

```typescript
// In src/transformers/include-resolver.ts

/**
 * Options for resolving includes
 */
export interface ResolveIncludesOptions {
  /** Base directory for resolving relative paths (usually the rule file's directory) */
  baseDir: string;
  /** Maximum depth of nested includes (default: 10) */
  maxDepth?: number;
  /** Optional callback for each resolved include (for logging/debugging) */
  onInclude?: (includePath: string, resolvedPath: string) => void;
}

/**
 * Result of resolving includes in content
 */
export interface ResolveIncludesResult {
  /** The content with all includes resolved (inlined) */
  content: string;
  /** List of all files that were included (in resolution order) */
  includedFiles: string[];
  /** Whether any includes were found and resolved */
  hasIncludes: boolean;
}

/**
 * Error types for include resolution
 */
export type IncludeErrorCode = 
  | 'CIRCULAR_INCLUDE'
  | 'FILE_NOT_FOUND'
  | 'MAX_DEPTH_EXCEEDED'
  | 'READ_ERROR';

/**
 * Include resolution error
 */
export interface IncludeError {
  code: IncludeErrorCode;
  message: string;
  /** The include path that caused the error */
  includePath: string;
  /** The file that contained the problematic include */
  sourceFile: string;
  /** Include chain leading to this error (for circular includes) */
  chain?: string[];
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use `Result<T, E>` for errors (see `src/utils/result.ts`)
- [x] Use `readFile()`, `resolvePath()` from `src/utils/fs.ts`
- [x] Export from `src/transformers/index.ts`
- [x] No `any` types - use `unknown` + type guards where needed
- [x] Run `npm run lint --fix` after implementation
- [x] Run `npm run typecheck` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Include Directive Pattern

```typescript
/**
 * Match @include directives in content
 * Format: @include path/to/file.md
 * 
 * Rules:
 * - Must be on its own line (optionally with whitespace before)
 * - Path is relative to the containing file
 * - .md extension is required for clarity
 */
const INCLUDE_PATTERN = /^[ \t]*@include\s+(.+\.md)\s*$/gm;

// ❌ WRONG - Processing includes in frontmatter
function resolveIncludes(fullContent: string) {
  return fullContent.replace(INCLUDE_PATTERN, ...);
}

// ✅ CORRECT - Only process includes in markdown body, not frontmatter
function resolveIncludes(content: string, frontmatterEndLine: number) {
  // Skip frontmatter section when processing includes
  // Content passed to this function should already have frontmatter removed
}
```

#### 5.2.2 Circular Dependency Detection

```typescript
// ✅ CORRECT - Track visited files with a Set passed through recursion
async function resolveIncludesRecursive(
  content: string,
  currentFile: string,
  baseDir: string,
  visited: Set<string>,  // Track visited files
  depth: number,
  maxDepth: number
): Promise<Result<ResolveIncludesResult, IncludeError>> {
  // Normalize path for consistent tracking
  const normalizedPath = path.resolve(currentFile);
  
  // Check for circular include
  if (visited.has(normalizedPath)) {
    return err({
      code: 'CIRCULAR_INCLUDE',
      message: `Circular include detected: ${normalizedPath}`,
      includePath: normalizedPath,
      sourceFile: currentFile,
      chain: [...visited, normalizedPath],
    });
  }
  
  // Add to visited BEFORE processing includes
  visited.add(normalizedPath);
  
  // ... process includes ...
  
  // DON'T remove from visited - keep full chain for nested files
}
```

#### 5.2.3 Relative Path Resolution

```typescript
// ❌ WRONG - Resolving from project root
const includedPath = path.join(projectRoot, includePath);

// ✅ CORRECT - Resolve from the file that contains the include
function resolveIncludePath(includePath: string, sourceFile: string): string {
  const sourceDir = path.dirname(sourceFile);
  return path.resolve(sourceDir, includePath);
}

// Example:
// sourceFile: /project/.ai-tool-sync/rules/api/routes.md
// includePath: ../shared/base.md
// Result: /project/.ai-tool-sync/rules/shared/base.md
```

#### 5.2.4 Main Resolution Function

```typescript
/**
 * Resolve all @include directives in content
 * 
 * @param content - The markdown content (body only, frontmatter already removed)
 * @param sourceFile - Absolute path to the file containing this content
 * @param options - Resolution options
 * @returns Result with resolved content or error
 */
export async function resolveIncludes(
  content: string,
  sourceFile: string,
  options: ResolveIncludesOptions
): Promise<Result<ResolveIncludesResult, IncludeError>> {
  const visited = new Set<string>();
  const includedFiles: string[] = [];
  const maxDepth = options.maxDepth ?? 10;
  
  return resolveIncludesRecursive(
    content,
    sourceFile,
    options.baseDir,
    visited,
    includedFiles,
    0,
    maxDepth,
    options.onInclude
  );
}
```

#### 5.2.5 Recursive Resolution

```typescript
async function resolveIncludesRecursive(
  content: string,
  currentFile: string,
  baseDir: string,
  visited: Set<string>,
  includedFiles: string[],
  depth: number,
  maxDepth: number,
  onInclude?: (includePath: string, resolvedPath: string) => void
): Promise<Result<ResolveIncludesResult, IncludeError>> {
  // Check depth limit
  if (depth > maxDepth) {
    return err({
      code: 'MAX_DEPTH_EXCEEDED',
      message: `Include depth exceeded ${maxDepth}`,
      includePath: currentFile,
      sourceFile: currentFile,
    });
  }
  
  // Normalize and check circular
  const normalizedPath = path.resolve(currentFile);
  if (visited.has(normalizedPath)) {
    return err({
      code: 'CIRCULAR_INCLUDE',
      message: `Circular include detected`,
      includePath: normalizedPath,
      sourceFile: currentFile,
      chain: [...visited],
    });
  }
  
  visited.add(normalizedPath);
  
  // Find all includes in content
  const includes = findIncludes(content);
  
  if (includes.length === 0) {
    return ok({
      content,
      includedFiles: [],
      hasIncludes: false,
    });
  }
  
  let resolvedContent = content;
  
  // Process includes in order (replace from end to start to preserve positions)
  for (const include of includes.reverse()) {
    const resolvedPath = resolveIncludePath(include.path, currentFile);
    
    // Read included file
    const readResult = await readFile(resolvedPath);
    if (!readResult.ok) {
      return err({
        code: 'FILE_NOT_FOUND',
        message: `Include file not found: ${include.path}`,
        includePath: include.path,
        sourceFile: currentFile,
      });
    }
    
    // Extract body content (skip frontmatter in included files)
    const includedContent = extractBodyContent(readResult.value);
    
    // Recursively resolve includes in the included content
    const nestedResult = await resolveIncludesRecursive(
      includedContent,
      resolvedPath,
      path.dirname(resolvedPath),
      new Set(visited),  // Pass copy to allow sibling includes
      includedFiles,
      depth + 1,
      maxDepth,
      onInclude
    );
    
    if (!nestedResult.ok) {
      return nestedResult;
    }
    
    // Report the include
    if (onInclude) {
      onInclude(include.path, resolvedPath);
    }
    
    // Replace the include directive with resolved content
    resolvedContent = 
      resolvedContent.slice(0, include.start) +
      nestedResult.value.content +
      resolvedContent.slice(include.end);
    
    includedFiles.push(resolvedPath);
  }
  
  return ok({
    content: resolvedContent,
    includedFiles,
    hasIncludes: true,
  });
}
```

#### 5.2.6 Helper Functions

```typescript
interface IncludeMatch {
  path: string;      // The include path (e.g., "../shared/base.md")
  start: number;     // Start index in content
  end: number;       // End index in content
  line: string;      // Full matched line
}

/**
 * Find all include directives in content
 */
function findIncludes(content: string): IncludeMatch[] {
  const includes: IncludeMatch[] = [];
  const pattern = /^[ \t]*@include\s+(.+\.md)\s*$/gm;
  let match;
  
  while ((match = pattern.exec(content)) !== null) {
    includes.push({
      path: match[1].trim(),
      start: match.index,
      end: match.index + match[0].length,
      line: match[0],
    });
  }
  
  return includes;
}

/**
 * Extract body content, skipping frontmatter if present
 */
function extractBodyContent(content: string): string {
  // Check if content starts with frontmatter delimiter
  if (!content.trimStart().startsWith('---')) {
    return content;
  }
  
  // Find closing delimiter
  const match = content.match(/^---\r?\n[\s\S]*?\r?\n---\r?\n?/);
  if (match) {
    return content.slice(match[0].length);
  }
  
  return content;
}
```

### 5.3 Edge Cases to Handle

- [x] No includes in content → Return original content, `hasIncludes: false`
- [x] Self-include (`@include ./self.md`) → Return `CIRCULAR_INCLUDE` error
- [x] Direct circular include (A→B→A) → Return `CIRCULAR_INCLUDE` error with chain
- [x] Indirect circular (A→B→C→A) → Return `CIRCULAR_INCLUDE` error with full chain
- [x] Include file not found → Return `FILE_NOT_FOUND` error with path
- [x] Include file read error (permissions) → Return `READ_ERROR` error
- [x] Include depth exceeded → Return `MAX_DEPTH_EXCEEDED` error
- [x] Include in frontmatter (should not match) → Ignored, pattern only matches body
- [x] Multiple includes in same file → All resolved in order
- [x] Nested includes (A→B→C, no cycle) → All resolved recursively
- [x] Sibling includes (A includes B and C separately) → Both resolved
- [x] Empty include file → Replace with empty string
- [x] Included file has frontmatter → Frontmatter stripped, only body included
- [x] Whitespace before `@include` → Valid, whitespace preserved in pattern
- [x] Path with spaces (`@include path with spaces.md`) → Supported
- [x] Absolute paths → Supported but discouraged (for portability)

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/transformers/include-resolver.test.ts

describe('Include Resolver', () => {
  describe('resolveIncludes', () => {
    describe('happy path', () => {
      it('should return unchanged content when no includes', async () => { /* ... */ });
      it('should resolve single include', async () => { /* ... */ });
      it('should resolve multiple includes in order', async () => { /* ... */ });
      it('should resolve nested includes', async () => { /* ... */ });
      it('should strip frontmatter from included files', async () => { /* ... */ });
    });
    
    describe('error handling', () => {
      it('should detect direct circular include', async () => { /* ... */ });
      it('should detect indirect circular include', async () => { /* ... */ });
      it('should detect self-include', async () => { /* ... */ });
      it('should error on missing include file', async () => { /* ... */ });
      it('should error when max depth exceeded', async () => { /* ... */ });
    });
    
    describe('edge cases', () => {
      it('should handle include with leading whitespace', async () => { /* ... */ });
      it('should handle sibling includes', async () => { /* ... */ });
      it('should handle empty included file', async () => { /* ... */ });
      it('should not process includes in frontmatter', async () => { /* ... */ });
      it('should resolve relative paths correctly', async () => { /* ... */ });
    });
  });
  
  describe('findIncludes', () => {
    it('should find single include', () => { /* ... */ });
    it('should find multiple includes', () => { /* ... */ });
    it('should return empty array when no includes', () => { /* ... */ });
    it('should match only .md files', () => { /* ... */ });
  });
  
  describe('extractBodyContent', () => {
    it('should strip frontmatter', () => { /* ... */ });
    it('should return content as-is when no frontmatter', () => { /* ... */ });
  });
});
```

### 6.2 Test Fixtures

```
tests/fixtures/includes/
├── base.md           # Simple content to include
├── with-include.md   # File that includes base.md
├── nested-a.md       # Includes nested-b.md
├── nested-b.md       # Simple content (no includes)
├── circular-a.md     # Includes circular-b.md
├── circular-b.md     # Includes circular-a.md (creates cycle)
├── with-frontmatter.md  # Has frontmatter that should be stripped
├── empty.md          # Empty file
└── deep/
    └── nested.md     # Tests relative path resolution from subdirectory
```

### 6.3 Required Test Cases

```typescript
// Test: Single include resolution
it('should resolve single include', async () => {
  const baseContent = 'This is the base content.';
  const mainContent = `# My Rule

@include base.md

More content here.`;

  // Mock file system or use actual fixtures
  const result = await resolveIncludes(
    mainContent,
    '/project/rules/main.md',
    { baseDir: '/project/rules' }
  );

  expect(result.ok).toBe(true);
  if (result.ok) {
    expect(result.value.content).toContain('This is the base content.');
    expect(result.value.content).toContain('# My Rule');
    expect(result.value.content).toContain('More content here.');
    expect(result.value.content).not.toContain('@include');
    expect(result.value.hasIncludes).toBe(true);
    expect(result.value.includedFiles).toHaveLength(1);
  }
});

// Test: Circular include detection
it('should detect circular include', async () => {
  // circular-a.md includes circular-b.md
  // circular-b.md includes circular-a.md
  
  const result = await resolveIncludes(
    '@include circular-b.md',
    '/project/rules/circular-a.md',
    { baseDir: '/project/rules' }
  );

  expect(result.ok).toBe(false);
  if (!result.ok) {
    expect(result.error.code).toBe('CIRCULAR_INCLUDE');
    expect(result.error.chain).toBeDefined();
  }
});

// Test: Nested includes
it('should resolve nested includes', async () => {
  // a.md includes b.md
  // b.md includes c.md
  // c.md has no includes
  
  const result = await resolveIncludes(
    '@include b.md',
    '/project/rules/a.md',
    { baseDir: '/project/rules' }
  );

  expect(result.ok).toBe(true);
  if (result.ok) {
    // Content from all three files should be present
    expect(result.value.includedFiles).toHaveLength(2); // b.md and c.md
  }
});

// Test: Frontmatter stripping
it('should strip frontmatter from included files', async () => {
  const includedContent = `---
name: included
version: 1.0.0
---

# Included Content

This is the body.`;

  const result = await resolveIncludes(
    '@include with-frontmatter.md',
    '/project/rules/main.md',
    { baseDir: '/project/rules' }
  );

  expect(result.ok).toBe(true);
  if (result.ok) {
    expect(result.value.content).toContain('# Included Content');
    expect(result.value.content).not.toContain('name: included');
    expect(result.value.content).not.toContain('---');
  }
});

// Test: Relative path resolution
it('should resolve relative paths from include location', async () => {
  // main.md in /rules/ includes ../shared/base.md
  // which should resolve to /shared/base.md
  
  const content = '@include ../shared/base.md';
  
  const result = await resolveIncludes(
    content,
    '/project/rules/main.md',
    { baseDir: '/project/rules' }
  );

  expect(result.ok).toBe(true);
  if (result.ok) {
    expect(result.value.includedFiles[0]).toBe('/project/shared/base.md');
  }
});
```

## 7. Integration Points

- **Imports from**:
  - `src/utils/fs.ts` - `readFile`, `resolvePath`
  - `src/utils/result.ts` - `Result`, `ok`, `err`
  - `src/parsers/frontmatter.ts` - `hasFrontmatter` (for reference pattern)

- **Exports to**:
  - `src/transformers/index.ts` - Add `resolveIncludes` export
  - Will be used by rule loading pipeline (future integration in T226 or loader updates)

- **Future integration** (not in this task):
  - `src/loaders/local.ts` - Call `resolveIncludes()` after reading rule files
  - `src/cli/commands/sync.ts` - Apply include resolution during sync

## 8. Acceptance Criteria

- [x] `resolveIncludes()` resolves `@include` directives in markdown content
- [x] Relative paths are resolved from the including file's location
- [x] Circular includes are detected and return descriptive error with chain
- [x] Nested includes are supported up to configurable max depth
- [x] Frontmatter is stripped from included files
- [x] All tests pass (`npm test -- include-resolver.test.ts`)
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)
- [x] Exports added to `src/transformers/index.ts`
- [x] plan.md is updated with completion status

## 9. Out of Scope

- Integration with rule loader (future task)
- CLI flag to disable include resolution
- Include path aliases (e.g., `@shared/` prefix)
- Conditional includes (T226 - `when:` syntax)
- Include caching across multiple files
- Glob patterns in include paths
- Remote URL includes

## 10. Implementation Checklist

1. [x] Create `src/transformers/include-resolver.ts` with interfaces
2. [x] Implement `findIncludes()` helper function
3. [x] Implement `extractBodyContent()` helper function
4. [x] Implement `resolveIncludePath()` helper function
5. [x] Implement `resolveIncludesRecursive()` internal function
6. [x] Implement `resolveIncludes()` main export function
7. [x] Export from `src/transformers/index.ts`
8. [x] Create test fixtures in `tests/fixtures/includes/`
9. [x] Add tests to `tests/unit/transformers/include-resolver.test.ts`
10. [x] Run `npm test -- include-resolver.test.ts`
11. [x] Run `npm run lint --fix`
12. [x] Run `npm run typecheck`
13. [x] Update plan.md with T225 completion status

## 11. Example Usage

### Input Rule File (`.ai-tool-sync/rules/api/routes.md`)

```markdown
---
name: api-routes
description: API route conventions
globs:
  - "src/routes/**/*.ts"
---

# API Routes

This rule applies to API route definitions.

@include ../shared/naming-conventions.md

## Route-Specific Rules

- Use RESTful naming
- Group related routes

@include ../shared/error-handling.md
```

### Included File (`.ai-tool-sync/rules/shared/naming-conventions.md`)

```markdown
---
name: naming-conventions-fragment
description: Reusable naming conventions (included by other rules)
---

## Naming Conventions

- Use camelCase for variables
- Use PascalCase for types
- Use SCREAMING_SNAKE_CASE for constants
```

### Resolved Output

```markdown
# API Routes

This rule applies to API route definitions.

## Naming Conventions

- Use camelCase for variables
- Use PascalCase for types
- Use SCREAMING_SNAKE_CASE for constants

## Route-Specific Rules

- Use RESTful naming
- Group related routes

## Error Handling

- Always wrap async operations in try-catch
- Return consistent error responses
```

Note: The frontmatter from included files is stripped—only the body content is inlined.

