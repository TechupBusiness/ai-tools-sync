# T231: Implement Rule Linting

> **Priority**: P2 | **Wave**: 9 | **Track**: B (Validation & Preview)
> **Depends on**: T090-T096 ✅ (CLI commands)
> **Estimated complexity**: Medium

## 1. Objective

Implement a dedicated rule linting system that validates rules for common issues, checks frontmatter schema compliance, warns on deprecated fields, and suggests best practices. This extends beyond the existing validation (which only checks basic schema compliance) to provide actionable feedback for improving rule quality. The linter can be invoked via `ai-sync lint` command or integrated into the existing `validate` command with a `--lint` flag.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/cli/commands/validate.ts` - **Entire file**: Command structure, output formatting, `checkForIssues()` pattern
- `src/config/validator.ts` - **Lines 15-29**: `ValidationContext` class pattern for accumulating errors
- `src/parsers/rule.ts` - **Lines 85-222**: `validateRuleFields()` for basic validation; lint rules should complement this
- `src/parsers/types.ts` - **Lines 98-107**: `ContentValidationError` interface to reuse
- `tests/unit/cli/validate.test.ts` - **Test patterns** for CLI command testing

## 3. File Structure

```
src/
├── linters/
│   ├── index.ts              # Public exports
│   ├── rule-linter.ts        # Rule linting logic
│   ├── types.ts              # Lint result types
│   └── rules/                # Individual lint rules
│       ├── index.ts          # Export all lint rules
│       ├── deprecated-fields.ts
│       ├── best-practices.ts
│       └── schema-compliance.ts
├── cli/
│   └── commands/
│       └── lint.ts           # New lint CLI command
tests/
└── unit/
    └── linters/
        ├── rule-linter.test.ts
        └── rules/
            ├── deprecated-fields.test.ts
            ├── best-practices.test.ts
            └── schema-compliance.test.ts
```

## 4. Interfaces & Types

### 4.1 Lint Result Types

```typescript
// src/linters/types.ts

/**
 * Severity levels for lint issues
 */
export type LintSeverity = 'error' | 'warning' | 'info';

/**
 * A single lint issue found in a rule
 */
export interface LintIssue {
  /** Unique rule identifier (e.g., "deprecated-field", "missing-description") */
  ruleId: string;
  /** Human-readable message */
  message: string;
  /** Severity level */
  severity: LintSeverity;
  /** Path to the problematic field (e.g., "frontmatter.globs[0]") */
  path?: string;
  /** The problematic value */
  value?: unknown;
  /** Suggested fix or action */
  suggestion?: string;
  /** Line number in source file (if available) */
  line?: number;
}

/**
 * Result of linting a single rule file
 */
export interface RuleLintResult {
  /** Path to the rule file */
  filePath: string;
  /** Rule name (from frontmatter) */
  ruleName: string;
  /** All issues found */
  issues: LintIssue[];
  /** Convenience: has any errors */
  hasErrors: boolean;
  /** Convenience: has any warnings */
  hasWarnings: boolean;
}

/**
 * Result of linting all rules
 */
export interface LintResult {
  /** Results per rule file */
  rules: RuleLintResult[];
  /** Total counts by severity */
  summary: {
    errors: number;
    warnings: number;
    info: number;
    filesLinted: number;
    filesWithIssues: number;
  };
  /** Overall success (no errors) */
  success: boolean;
}

/**
 * Options for the linter
 */
export interface LintOptions {
  /** Treat warnings as errors */
  strict?: boolean;
  /** Specific lint rules to run (empty = all) */
  rules?: string[];
  /** Rules to skip */
  ignore?: string[];
  /** Include info-level issues */
  includeInfo?: boolean;
  /** Fix auto-fixable issues (future) */
  fix?: boolean;
}
```

### 4.2 Lint Rule Interface

```typescript
// src/linters/types.ts

import type { ParsedRule } from '../parsers/rule.js';

/**
 * A single lint rule definition
 */
export interface LintRule {
  /** Unique identifier (e.g., "no-deprecated-fields") */
  id: string;
  /** Short description */
  description: string;
  /** Default severity */
  defaultSeverity: LintSeverity;
  /** Check a parsed rule and return issues */
  check: (rule: ParsedRule, context: LintContext) => LintIssue[];
}

/**
 * Context passed to lint rules
 */
export interface LintContext {
  /** All rules being linted (for cross-rule checks) */
  allRules: ParsedRule[];
  /** Project configuration */
  config?: unknown;
}
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [x] Use `Result<T, E>` for errors (see `src/utils/result.ts`)
- [x] Use `LintError` class extending `BaseError` for fatal linter errors
- [x] Export only from `src/linters/index.ts`
- [x] No `any` types
- [x] Run `npm run lint --fix` after implementation
- [x] Run `npm run typecheck` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Main Linter Function

```typescript
// src/linters/rule-linter.ts

import { type Result, ok, err } from '../utils/result.js';
import type { ParsedRule } from '../parsers/rule.js';
import type { LintResult, LintOptions, LintContext, LintRule } from './types.js';
import { getAllLintRules } from './rules/index.js';

/**
 * Lint all parsed rules
 */
export function lintRules(
  rules: ParsedRule[],
  options: LintOptions = {}
): Result<LintResult, Error> {
  const lintRules = getEnabledLintRules(options);
  const context: LintContext = { allRules: rules };
  
  const ruleResults: RuleLintResult[] = [];
  let totalErrors = 0;
  let totalWarnings = 0;
  let totalInfo = 0;
  let filesWithIssues = 0;

  for (const rule of rules) {
    const issues: LintIssue[] = [];
    
    for (const lintRule of lintRules) {
      const ruleIssues = lintRule.check(rule, context);
      issues.push(...ruleIssues);
    }
    
    // Filter by severity if needed
    const filteredIssues = options.includeInfo 
      ? issues 
      : issues.filter(i => i.severity !== 'info');
    
    const hasErrors = filteredIssues.some(i => i.severity === 'error');
    const hasWarnings = filteredIssues.some(i => i.severity === 'warning');
    
    if (filteredIssues.length > 0) {
      filesWithIssues++;
    }
    
    totalErrors += filteredIssues.filter(i => i.severity === 'error').length;
    totalWarnings += filteredIssues.filter(i => i.severity === 'warning').length;
    totalInfo += filteredIssues.filter(i => i.severity === 'info').length;
    
    ruleResults.push({
      filePath: rule.filePath ?? 'unknown',
      ruleName: rule.frontmatter.name,
      issues: filteredIssues,
      hasErrors,
      hasWarnings,
    });
  }
  
  // In strict mode, warnings count as errors
  const effectiveErrors = options.strict ? totalErrors + totalWarnings : totalErrors;
  
  return ok({
    rules: ruleResults,
    summary: {
      errors: totalErrors,
      warnings: totalWarnings,
      info: totalInfo,
      filesLinted: rules.length,
      filesWithIssues,
    },
    success: effectiveErrors === 0,
  });
}

/**
 * Get enabled lint rules based on options
 */
function getEnabledLintRules(options: LintOptions): LintRule[] {
  const allRules = getAllLintRules();
  
  // Filter by explicit include list
  let enabled = options.rules?.length 
    ? allRules.filter(r => options.rules!.includes(r.id))
    : allRules;
  
  // Remove ignored rules
  if (options.ignore?.length) {
    enabled = enabled.filter(r => !options.ignore!.includes(r.id));
  }
  
  return enabled;
}
```

#### 5.2.2 Deprecated Fields Lint Rule

```typescript
// src/linters/rules/deprecated-fields.ts

import type { LintRule, LintIssue } from '../types.js';
import type { ParsedRule } from '../../parsers/rule.js';

/**
 * Deprecated field mappings: old field -> { replacement, since }
 */
const DEPRECATED_FIELDS: Record<string, { replacement?: string; since: string; message?: string }> = {
  // Example deprecated fields (adjust based on actual deprecations)
  'alwaysApply': {
    replacement: 'always_apply',
    since: '1.0.0',
    message: 'Use snake_case field name for consistency with generic format',
  },
};

/**
 * Check for deprecated fields in frontmatter
 */
export const deprecatedFieldsRule: LintRule = {
  id: 'no-deprecated-fields',
  description: 'Disallow deprecated frontmatter fields',
  defaultSeverity: 'warning',
  
  check(rule: ParsedRule): LintIssue[] {
    const issues: LintIssue[] = [];
    const frontmatter = rule.frontmatter as Record<string, unknown>;
    
    for (const [field, info] of Object.entries(DEPRECATED_FIELDS)) {
      if (field in frontmatter) {
        issues.push({
          ruleId: 'no-deprecated-fields',
          severity: 'warning',
          path: `frontmatter.${field}`,
          value: frontmatter[field],
          message: `Field '${field}' is deprecated since v${info.since}`,
          suggestion: info.replacement 
            ? `Use '${info.replacement}' instead. ${info.message ?? ''}`
            : info.message,
        });
      }
    }
    
    return issues;
  },
};
```

#### 5.2.3 Best Practices Lint Rules

```typescript
// src/linters/rules/best-practices.ts

import type { LintRule, LintIssue, LintContext } from '../types.js';
import type { ParsedRule } from '../../parsers/rule.js';

/**
 * Check for missing description
 */
export const missingDescriptionRule: LintRule = {
  id: 'require-description',
  description: 'Require description in frontmatter',
  defaultSeverity: 'warning',
  
  check(rule: ParsedRule): LintIssue[] {
    if (!rule.frontmatter.description) {
      return [{
        ruleId: 'require-description',
        severity: 'warning',
        path: 'frontmatter.description',
        message: 'Rule is missing a description',
        suggestion: 'Add a description to help users understand what this rule does',
      }];
    }
    return [];
  },
};

/**
 * Check for rules without globs that aren't always_apply
 */
export const unreachableRuleCheck: LintRule = {
  id: 'no-unreachable-rule',
  description: 'Warn when rule may never trigger',
  defaultSeverity: 'warning',
  
  check(rule: ParsedRule): LintIssue[] {
    const { always_apply, globs } = rule.frontmatter;
    
    if (!always_apply && (!globs || globs.length === 0)) {
      return [{
        ruleId: 'no-unreachable-rule',
        severity: 'warning',
        path: 'frontmatter',
        message: 'Rule has no globs and always_apply is false - it may never trigger',
        suggestion: 'Add glob patterns or set always_apply: true',
      }];
    }
    return [];
  },
};

/**
 * Check for very large rule content
 */
export const ruleSizeCheck: LintRule = {
  id: 'max-rule-size',
  description: 'Warn when rule content is too large',
  defaultSeverity: 'info',
  
  check(rule: ParsedRule): LintIssue[] {
    const contentSize = rule.content.length;
    const MAX_SIZE = 10000; // 10KB
    
    if (contentSize > MAX_SIZE) {
      return [{
        ruleId: 'max-rule-size',
        severity: 'info',
        message: `Rule content is ${Math.round(contentSize / 1024)}KB (exceeds ${MAX_SIZE / 1000}KB recommendation)`,
        suggestion: 'Consider splitting into smaller, focused rules',
      }];
    }
    return [];
  },
};

/**
 * Check for duplicate rule names
 */
export const duplicateNameCheck: LintRule = {
  id: 'no-duplicate-names',
  description: 'Disallow duplicate rule names',
  defaultSeverity: 'error',
  
  check(rule: ParsedRule, context: LintContext): LintIssue[] {
    const duplicates = context.allRules.filter(
      r => r.frontmatter.name === rule.frontmatter.name && r.filePath !== rule.filePath
    );
    
    if (duplicates.length > 0) {
      return [{
        ruleId: 'no-duplicate-names',
        severity: 'error',
        path: 'frontmatter.name',
        value: rule.frontmatter.name,
        message: `Duplicate rule name '${rule.frontmatter.name}'`,
        suggestion: `Also defined in: ${duplicates.map(d => d.filePath).join(', ')}`,
      }];
    }
    return [];
  },
};

/**
 * Check for invalid glob patterns
 */
export const invalidGlobCheck: LintRule = {
  id: 'valid-glob-patterns',
  description: 'Validate glob pattern syntax',
  defaultSeverity: 'error',
  
  check(rule: ParsedRule): LintIssue[] {
    const issues: LintIssue[] = [];
    const globs = rule.frontmatter.globs ?? [];
    
    for (const [i, glob] of globs.entries()) {
      // Check for common glob mistakes
      if (glob.includes('\\')) {
        issues.push({
          ruleId: 'valid-glob-patterns',
          severity: 'error',
          path: `frontmatter.globs[${i}]`,
          value: glob,
          message: 'Glob pattern contains backslashes',
          suggestion: 'Use forward slashes (/) for path separators',
        });
      }
      
      if (glob.startsWith('/')) {
        issues.push({
          ruleId: 'valid-glob-patterns',
          severity: 'warning',
          path: `frontmatter.globs[${i}]`,
          value: glob,
          message: 'Glob pattern starts with / (absolute path)',
          suggestion: 'Globs are relative to project root; remove leading /',
        });
      }
      
      // Check for empty glob
      if (glob.trim() === '') {
        issues.push({
          ruleId: 'valid-glob-patterns',
          severity: 'error',
          path: `frontmatter.globs[${i}]`,
          value: glob,
          message: 'Empty glob pattern',
          suggestion: 'Remove empty glob or provide a valid pattern',
        });
      }
    }
    
    return issues;
  },
};

/**
 * Check for missing requires references
 */
export const invalidRequiresCheck: LintRule = {
  id: 'valid-requires',
  description: 'Validate requires references exist',
  defaultSeverity: 'error',
  
  check(rule: ParsedRule, context: LintContext): LintIssue[] {
    const issues: LintIssue[] = [];
    const requires = rule.frontmatter.requires ?? [];
    const availableNames = new Set(context.allRules.map(r => r.frontmatter.name));
    
    for (const [i, req] of requires.entries()) {
      if (!availableNames.has(req)) {
        issues.push({
          ruleId: 'valid-requires',
          severity: 'error',
          path: `frontmatter.requires[${i}]`,
          value: req,
          message: `Required rule '${req}' does not exist`,
          suggestion: 'Check the rule name or remove the reference',
        });
      }
    }
    
    return issues;
  },
};
```

#### 5.2.4 Export All Lint Rules

```typescript
// src/linters/rules/index.ts

import type { LintRule } from '../types.js';
import { deprecatedFieldsRule } from './deprecated-fields.js';
import {
  missingDescriptionRule,
  unreachableRuleCheck,
  ruleSizeCheck,
  duplicateNameCheck,
  invalidGlobCheck,
  invalidRequiresCheck,
} from './best-practices.js';

/**
 * All available lint rules
 */
export const ALL_LINT_RULES: LintRule[] = [
  // Deprecated fields
  deprecatedFieldsRule,
  
  // Best practices
  missingDescriptionRule,
  unreachableRuleCheck,
  ruleSizeCheck,
  duplicateNameCheck,
  invalidGlobCheck,
  invalidRequiresCheck,
];

/**
 * Get all lint rules
 */
export function getAllLintRules(): LintRule[] {
  return [...ALL_LINT_RULES];
}

/**
 * Get a lint rule by ID
 */
export function getLintRuleById(id: string): LintRule | undefined {
  return ALL_LINT_RULES.find(r => r.id === id);
}
```

#### 5.2.5 CLI Command

```typescript
// src/cli/commands/lint.ts

import * as path from 'node:path';

import { loadConfig } from '../../config/loader.js';
import { createLocalLoader } from '../../loaders/local.js';
import { lintRules } from '../../linters/rule-linter.js';
import { getAllLintRules } from '../../linters/rules/index.js';
import {
  printHeader,
  printSubHeader,
  printSuccess,
  printWarning,
  printError,
  printSummary,
  printNewLine,
  printKeyValue,
} from '../output.js';

import type { LintOptions, LintResult, LintIssue } from '../../linters/types.js';

/**
 * Options for the lint command
 */
export interface LintCommandOptions extends LintOptions {
  /** Project root directory */
  projectRoot?: string;
  /** Configuration directory name */
  configDir?: string;
  /** Enable verbose output */
  verbose?: boolean;
  /** List available lint rules */
  listRules?: boolean;
}

/**
 * Execute the lint command
 */
export async function lint(options: LintCommandOptions = {}): Promise<LintResult> {
  const projectRoot = path.resolve(options.projectRoot ?? process.cwd());
  
  // List rules mode
  if (options.listRules) {
    printHeader('Available Lint Rules');
    const rules = getAllLintRules();
    for (const rule of rules) {
      printKeyValue(rule.id, `[${rule.defaultSeverity}] ${rule.description}`);
    }
    return {
      rules: [],
      summary: { errors: 0, warnings: 0, info: 0, filesLinted: 0, filesWithIssues: 0 },
      success: true,
    };
  }
  
  printHeader('Lint Rules');
  
  // Load config
  const configResult = await loadConfig({ projectRoot, configDir: options.configDir });
  if (!configResult.ok) {
    printError(`Failed to load configuration: ${configResult.error.message}`);
    return {
      rules: [],
      summary: { errors: 1, warnings: 0, info: 0, filesLinted: 0, filesWithIssues: 0 },
      success: false,
    };
  }
  
  const config = configResult.value;
  
  // Load rules
  printSubHeader('Loading rules');
  const localLoader = createLocalLoader();
  const loadResult = await localLoader.load(config.aiDir, {
    basePath: config.projectRoot,
    continueOnError: true,
  });
  
  if (loadResult.rules.length === 0) {
    printWarning('No rules found to lint');
    return {
      rules: [],
      summary: { errors: 0, warnings: 0, info: 0, filesLinted: 0, filesWithIssues: 0 },
      success: true,
    };
  }
  
  printSuccess(`Found ${loadResult.rules.length} rule(s)`);
  
  // Run linter
  printSubHeader('Running lint checks');
  
  const lintResult = lintRules(loadResult.rules, {
    strict: options.strict,
    rules: options.rules,
    ignore: options.ignore,
    includeInfo: options.includeInfo,
  });
  
  if (!lintResult.ok) {
    printError(`Linting failed: ${lintResult.error.message}`);
    return {
      rules: [],
      summary: { errors: 1, warnings: 0, info: 0, filesLinted: 0, filesWithIssues: 0 },
      success: false,
    };
  }
  
  const result = lintResult.value;
  
  // Print results
  for (const ruleResult of result.rules) {
    if (ruleResult.issues.length === 0) {
      if (options.verbose) {
        printSuccess(`${ruleResult.filePath}: OK`);
      }
      continue;
    }
    
    printNewLine();
    printSubHeader(ruleResult.filePath);
    
    for (const issue of ruleResult.issues) {
      printLintIssue(issue);
    }
  }
  
  // Summary
  printNewLine();
  printSummary({
    success: result.success,
    message: result.success
      ? `Linted ${result.summary.filesLinted} file(s) with no errors`
      : `Found ${result.summary.errors} error(s), ${result.summary.warnings} warning(s)`,
  });
  
  if (options.verbose) {
    printKeyValue('Files linted', String(result.summary.filesLinted));
    printKeyValue('Files with issues', String(result.summary.filesWithIssues));
    printKeyValue('Errors', String(result.summary.errors));
    printKeyValue('Warnings', String(result.summary.warnings));
    if (options.includeInfo) {
      printKeyValue('Info', String(result.summary.info));
    }
  }
  
  return result;
}

/**
 * Print a lint issue with appropriate formatting
 */
function printLintIssue(issue: LintIssue): void {
  const prefix = issue.path ? `${issue.path}: ` : '';
  const message = `${prefix}${issue.message} (${issue.ruleId})`;
  
  switch (issue.severity) {
    case 'error':
      printError(message);
      break;
    case 'warning':
      printWarning(message);
      break;
    case 'info':
      console.log(`  ℹ ${message}`);
      break;
  }
  
  if (issue.suggestion) {
    console.log(`    → ${issue.suggestion}`);
  }
}
```

### 5.3 Edge Cases to Handle

- [x] No rules found → Return success with 0 files linted
- [x] Rule file fails to parse → Include error in results, continue linting others
- [x] Circular requires references → Detect and report as error
- [x] Missing frontmatter entirely → Caught by parser, not linter
- [x] Empty globs array vs undefined globs → Both trigger "unreachable" warning
- [x] Self-referential requires (rule requires itself) → Report as error
- [x] Unknown lint rule ID in `--rules` option → Warn and skip
- [x] All rules ignored via `--ignore` → Warn user, return empty results

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/linters/rule-linter.test.ts

describe('RuleLinter', () => {
  describe('lintRules', () => {
    it('should return success for valid rules', () => { /* ... */ });
    it('should detect deprecated fields', () => { /* ... */ });
    it('should detect duplicate names', () => { /* ... */ });
    it('should respect --strict flag', () => { /* ... */ });
    it('should filter rules with --rules option', () => { /* ... */ });
    it('should exclude rules with --ignore option', () => { /* ... */ });
  });
});

// tests/unit/linters/rules/best-practices.test.ts

describe('Best Practice Rules', () => {
  describe('missingDescriptionRule', () => {
    it('should warn on missing description', () => { /* ... */ });
    it('should pass when description exists', () => { /* ... */ });
  });
  
  describe('unreachableRuleCheck', () => {
    it('should warn when no globs and not always_apply', () => { /* ... */ });
    it('should pass when always_apply is true', () => { /* ... */ });
    it('should pass when globs are defined', () => { /* ... */ });
  });
  
  describe('invalidGlobCheck', () => {
    it('should error on backslashes in globs', () => { /* ... */ });
    it('should warn on leading slash', () => { /* ... */ });
    it('should error on empty glob', () => { /* ... */ });
  });
});
```

### 6.2 Required Test Cases

```typescript
// Test: Linter returns success for valid rule
it('should return success for valid rules', () => {
  const rules: ParsedRule[] = [{
    frontmatter: {
      name: 'valid-rule',
      description: 'A valid rule',
      always_apply: true,
      globs: [],
      targets: ['cursor', 'claude'],
      requires: [],
      priority: 'medium',
    },
    content: '# Valid Rule\n\nSome content.',
    filePath: 'rules/valid.md',
  }];

  const result = lintRules(rules);
  
  expect(result.ok).toBe(true);
  expect(result.value.success).toBe(true);
  expect(result.value.summary.errors).toBe(0);
  expect(result.value.summary.warnings).toBe(0);
});

// Test: Detect unreachable rule
it('should warn when rule may never trigger', () => {
  const rules: ParsedRule[] = [{
    frontmatter: {
      name: 'unreachable-rule',
      always_apply: false,
      globs: [],
      targets: ['cursor'],
      requires: [],
      priority: 'medium',
    },
    content: '# Unreachable',
    filePath: 'rules/unreachable.md',
  }];

  const result = lintRules(rules);
  
  expect(result.ok).toBe(true);
  expect(result.value.rules[0].issues).toContainEqual(
    expect.objectContaining({
      ruleId: 'no-unreachable-rule',
      severity: 'warning',
    })
  );
});

// Test: Detect duplicate names
it('should error on duplicate rule names', () => {
  const rules: ParsedRule[] = [
    {
      frontmatter: { name: 'duplicate', always_apply: true, globs: [], targets: ['cursor'], requires: [], priority: 'medium' },
      content: '# First',
      filePath: 'rules/first.md',
    },
    {
      frontmatter: { name: 'duplicate', always_apply: true, globs: [], targets: ['cursor'], requires: [], priority: 'medium' },
      content: '# Second',
      filePath: 'rules/second.md',
    },
  ];

  const result = lintRules(rules);
  
  expect(result.ok).toBe(true);
  expect(result.value.success).toBe(false);
  expect(result.value.summary.errors).toBeGreaterThan(0);
  expect(result.value.rules[0].issues).toContainEqual(
    expect.objectContaining({
      ruleId: 'no-duplicate-names',
      severity: 'error',
    })
  );
});

// Test: Strict mode treats warnings as errors
it('should treat warnings as errors in strict mode', () => {
  const rules: ParsedRule[] = [{
    frontmatter: {
      name: 'no-description',
      always_apply: true,
      globs: [],
      targets: ['cursor'],
      requires: [],
      priority: 'medium',
    },
    content: '# No description',
    filePath: 'rules/no-desc.md',
  }];

  const result = lintRules(rules, { strict: true });
  
  expect(result.ok).toBe(true);
  expect(result.value.success).toBe(false); // Warning becomes error
});

// Test: Invalid requires reference
it('should error on invalid requires reference', () => {
  const rules: ParsedRule[] = [{
    frontmatter: {
      name: 'has-invalid-requires',
      always_apply: true,
      globs: [],
      targets: ['cursor'],
      requires: ['non-existent-rule'],
      priority: 'medium',
    },
    content: '# Has invalid requires',
    filePath: 'rules/invalid-req.md',
  }];

  const result = lintRules(rules);
  
  expect(result.ok).toBe(true);
  expect(result.value.rules[0].issues).toContainEqual(
    expect.objectContaining({
      ruleId: 'valid-requires',
      severity: 'error',
      message: expect.stringContaining('non-existent-rule'),
    })
  );
});
```

## 7. Integration Points

- **Imports from**:
  - `src/parsers/rule.ts` - `ParsedRule` type
  - `src/parsers/types.ts` - `ContentValidationError` for reference
  - `src/utils/result.ts` - `Result`, `ok`, `err`
  - `src/loaders/local.ts` - `createLocalLoader` for loading rules
  - `src/config/loader.ts` - `loadConfig` for configuration
  - `src/cli/output.ts` - Output formatting functions

- **Exports to**:
  - `src/cli/commands/lint.ts` - Main CLI command
  - `src/cli/commands/validate.ts` - Optional integration via `--lint` flag

- **CLI Registration** (in `src/cli/index.ts`):
  ```typescript
  import { lint } from './commands/lint.js';
  
  program
    .command('lint')
    .description('Lint rules for common issues')
    .option('-s, --strict', 'Treat warnings as errors')
    .option('-r, --rules <rules>', 'Comma-separated lint rules to run')
    .option('-i, --ignore <rules>', 'Comma-separated lint rules to ignore')
    .option('--include-info', 'Include info-level issues')
    .option('--list-rules', 'List available lint rules')
    .option('-v, --verbose', 'Verbose output')
    .action(async (opts) => {
      const result = await lint({
        projectRoot: program.opts().project,
        configDir: program.opts().configDir,
        ...opts,
        rules: opts.rules?.split(','),
        ignore: opts.ignore?.split(','),
      });
      process.exit(result.success ? 0 : 1);
    });
  ```

## 8. Acceptance Criteria

- [ ] `ai-sync lint` command works and reports issues
- [ ] `ai-sync lint --list-rules` shows available lint rules
- [ ] `ai-sync lint --strict` treats warnings as errors
- [ ] `ai-sync lint --rules rule1,rule2` runs only specified rules
- [ ] `ai-sync lint --ignore rule1,rule2` skips specified rules
- [ ] All lint rules detect their respective issues correctly
- [ ] Exit code 0 on success, 1 on lint errors
- [ ] All tests pass (`npm test -- rule-linter.test.ts`)
- [ ] No lint errors (`npm run lint`)
- [ ] Types are strict (no `any`)
- [ ] Exports added to `src/linters/index.ts`
- [ ] Command added to CLI in `src/cli/index.ts`
- [ ] plan.md is updated with completion status

## 9. Out of Scope

- Persona/command/hook linting (future tasks)
- Auto-fix capabilities (`--fix` flag - prepare interface but don't implement)
- Custom lint rule configuration in `config.yaml`
- IDE integration (LSP, VS Code extension)
- Caching of lint results

## 10. Implementation Checklist

1. [x] Create `src/linters/types.ts` with all type definitions
2. [x] Create `src/linters/rules/deprecated-fields.ts`
3. [x] Create `src/linters/rules/best-practices.ts`
4. [x] Create `src/linters/rules/index.ts` with `getAllLintRules()`
5. [x] Create `src/linters/rule-linter.ts` with `lintRules()` function
6. [x] Create `src/linters/index.ts` with public exports
7. [x] Create `src/cli/commands/lint.ts` command
8. [x] Register command in `src/cli/index.ts`
9. [x] Add tests in `tests/unit/linters/`
10. [x] Run `npm test -- rule-linter`
11. [x] Run `npm run lint --fix`
12. [x] Run `npm run typecheck`
13. [x] Update plan.md with T231 completion status

## 11. Example Output

```bash
$ ai-sync lint

╭─────────────────────────────────────╮
│         Lint Rules                  │
╰─────────────────────────────────────╯

── Loading rules ──
✓ Found 5 rule(s)

── Running lint checks ──

rules/database.md
  ⚠ frontmatter: Rule has no globs and always_apply is false - it may never trigger (no-unreachable-rule)
    → Add glob patterns or set always_apply: true
  ⚠ frontmatter.description: Rule is missing a description (require-description)
    → Add a description to help users understand what this rule does

rules/deprecated.md
  ⚠ frontmatter.alwaysApply: Field 'alwaysApply' is deprecated since v1.0.0 (no-deprecated-fields)
    → Use 'always_apply' instead. Use snake_case field name for consistency with generic format

rules/broken.md
  ✗ frontmatter.requires[0]: Required rule 'nonexistent' does not exist (valid-requires)
    → Check the rule name or remove the reference
  ✗ frontmatter.globs[0]: Glob pattern contains backslashes (valid-glob-patterns)
    → Use forward slashes (/) for path separators

╭─────────────────────────────────────╮
│  Found 2 error(s), 3 warning(s)     │
╰─────────────────────────────────────╯
```

```bash
$ ai-sync lint --list-rules

╭─────────────────────────────────────╮
│       Available Lint Rules          │
╰─────────────────────────────────────╯

no-deprecated-fields     [warning] Disallow deprecated frontmatter fields
require-description      [warning] Require description in frontmatter
no-unreachable-rule      [warning] Warn when rule may never trigger
max-rule-size            [info] Warn when rule content is too large
no-duplicate-names       [error] Disallow duplicate rule names
valid-glob-patterns      [error] Validate glob pattern syntax
valid-requires           [error] Validate requires references exist
```

