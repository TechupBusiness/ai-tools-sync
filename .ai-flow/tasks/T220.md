# T220: Implement Per-Run Manifest with File Hashes

> **Priority**: P2 | **Wave**: 4 | **Track**: A (Manifest Infrastructure)
> **Depends on**: T188-T190 ✅ (manifest system)
> **Estimated complexity**: Medium

## 1. Objective

Upgrade the sync command to generate V2 manifests with SHA256 file hashes at generation time, and store historical snapshots in `.ai-tool-sync/history/<timestamp>.json`. This enables safe cleanup by comparing current file hashes against last-generated hashes—unchanged files can be safely deleted while user-modified files are protected from accidental deletion.

## 2. Prior Art (IMPORTANT)

Reference existing implementations to copy patterns from:
- `src/utils/manifest.ts` - **V2 types already exist** (`ManifestV2`, `ManifestFileEntry`, `computeFileHash`, `createManifestV2`, `isManifestV2`)
- `src/cli/commands/sync.ts` - **Lines 429-482**: Current manifest generation flow using `createManifest()` (V1)
- `src/utils/plugin-cache.ts` - **PluginCache class**: Pattern for managing versioned cache directories
- `src/cli/commands/clean.ts` - **cleanV2()**: Consumer of V2 manifests, uses `isFileModified()`
- `tests/unit/utils/manifest.test.ts` - Test patterns for manifest utilities

## 3. File Structure

```
src/
├── utils/
│   ├── manifest.ts           # Add collectFileHashes(), history storage
│   └── manifest-history.ts   # NEW: History snapshot management
├── cli/
│   └── commands/
│       └── sync.ts           # Update to use V2 manifest with hashes
tests/
└── unit/
    └── utils/
        ├── manifest.test.ts        # Extend with V2 hash tests
        └── manifest-history.test.ts # NEW: History tests
```

## 4. Interfaces & Types

### 4.1 History Snapshot Types (NEW)

```typescript
// In src/utils/manifest-history.ts

/**
 * Snapshot filename format: <timestamp>.json
 * Example: 2024-01-15T10-30-00-000Z.json (colons replaced for filesystem safety)
 */

/**
 * Options for saving history snapshots
 */
export interface HistoryOptions {
  /** Configuration directory (default: '.ai-tool-sync') */
  configDir?: string;
  /** Maximum history entries to retain (default: 10) */
  maxHistory?: number;
}

/**
 * Result of listing history snapshots
 */
export interface HistoryEntry {
  /** Filename (e.g., '2024-01-15T10-30-00-000Z.json') */
  filename: string;
  /** Parsed timestamp */
  timestamp: Date;
  /** Full path to snapshot file */
  path: string;
}
```

### 4.2 Enhanced Manifest Types (extend existing)

```typescript
// In src/utils/manifest.ts - types already exist, no changes needed:
// - ManifestV2
// - ManifestFileEntry  
// - computeFileHash()
// - createManifestV2()
// - isManifestV2()

// NEW: Add to manifest.ts
/**
 * Collect file entries with computed hashes
 */
export async function collectFileEntriesWithHashes(
  files: string[],
  projectRoot: string
): Promise<Result<ManifestFileEntry[]>>;
```

## 5. Implementation Requirements

### 5.1 Must Follow (Project Patterns)

- [ ] Use `Result<T, E>` for all async operations (see `src/utils/result.ts`)
- [ ] Use `tryCatchAsync()` for file system operations
- [ ] Use `fileExists`, `readFile`, `writeFile`, `ensureDir` from `src/utils/fs.ts`
- [ ] Export only from `index.ts` (manifest-history exports via manifest.ts)
- [ ] No `any` types - use `unknown` with type guards
- [ ] Run `npm run lint --fix` after implementation

### 5.2 Critical Logic (Pitfall Prevention)

#### 5.2.1 Filename Safety for Timestamps

```typescript
// ❌ WRONG - Colons invalid on Windows
const filename = timestamp.toISOString() + '.json';
// Creates: 2024-01-15T10:30:00.000Z.json (fails on Windows)

// ✅ CORRECT - Replace unsafe characters
function timestampToFilename(timestamp: Date): string {
  return timestamp.toISOString().replace(/:/g, '-') + '.json';
}
// Creates: 2024-01-15T10-30-00.000Z.json
```

#### 5.2.2 Hash Collection with Error Handling

```typescript
// ❌ WRONG - Fail entire operation on single file error
const entries = await Promise.all(
  files.map(async (file) => ({
    path: file,
    hash: (await computeFileHash(path.join(projectRoot, file))).value!, // May throw!
  }))
);

// ✅ CORRECT - Collect errors, continue with valid entries
export async function collectFileEntriesWithHashes(
  files: string[],
  projectRoot: string
): Promise<Result<ManifestFileEntry[]>> {
  const entries: ManifestFileEntry[] = [];
  const errors: string[] = [];

  for (const file of files) {
    const filePath = path.join(projectRoot, file);
    const hashResult = await computeFileHash(filePath);
    
    if (hashResult.ok) {
      entries.push({ path: file, hash: hashResult.value });
    } else {
      errors.push(`Failed to hash ${file}: ${hashResult.error.message}`);
    }
  }

  // Warn but don't fail - some files may be deleted between generation and manifest
  if (errors.length > 0) {
    logger.warn(`Hash collection warnings: ${errors.length} file(s) skipped`);
    for (const error of errors) {
      logger.debug(error);
    }
  }

  return ok(entries);
}
```

#### 5.2.3 History Pruning

```typescript
// ✅ CORRECT - Prune old history entries
async function pruneHistory(
  historyDir: string,
  maxHistory: number
): Promise<Result<string[]>> {
  const entriesResult = await listHistory(historyDir);
  if (!entriesResult.ok) return entriesResult;

  const entries = entriesResult.value;
  
  // Sort by timestamp descending (newest first)
  entries.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

  const toDelete = entries.slice(maxHistory);
  const deleted: string[] = [];

  for (const entry of toDelete) {
    const result = await deleteFile(entry.path);
    if (result.ok) {
      deleted.push(entry.filename);
    }
  }

  return ok(deleted);
}
```

#### 5.2.4 Upgrade Sync to V2 Manifest

```typescript
// In src/cli/commands/sync.ts

// Change MANIFEST_VERSION
const MANIFEST_VERSION = '2.0.0';  // Was '1.0.0'

// In generateManifestAndGitignore():
// ❌ OLD - Creates V1 manifest
const manifest = createManifest(generatedFiles, directories, MANIFEST_VERSION);

// ✅ NEW - Creates V2 manifest with hashes
const entriesResult = await collectFileEntriesWithHashes(generatedFiles, config.projectRoot);
if (!entriesResult.ok) {
  result.warnings.push(`Failed to collect file hashes: ${entriesResult.error.message}`);
  // Fall back to V1 manifest
  const manifest = createManifest(generatedFiles, directories, '1.0.0');
  // ... write manifest
} else {
  const manifest = createManifestV2(entriesResult.value, directories, MANIFEST_VERSION);
  // ... write manifest and save history snapshot
}
```

### 5.3 Edge Cases to Handle

- [ ] Empty file list → Create V2 manifest with empty `files` array
- [ ] File deleted between generation and hashing → Skip with warning, continue
- [ ] File read error (permissions) → Skip with warning, continue
- [ ] History directory doesn't exist → Create it via `ensureDir()`
- [ ] Corrupted history file → Skip when listing, don't fail entire operation
- [ ] No config directory → Use default `.ai-tool-sync`
- [ ] Max history = 0 → Don't save history snapshots
- [ ] First sync (no history) → Create history directory and first snapshot

## 6. Test Requirements

### 6.1 Test File Structure

```typescript
// tests/unit/utils/manifest-history.test.ts

describe('Manifest History', () => {
  describe('timestampToFilename', () => {
    it('should convert timestamp to safe filename', () => { /* ... */ });
    it('should produce consistent output', () => { /* ... */ });
  });

  describe('filenameToTimestamp', () => {
    it('should parse filename back to timestamp', () => { /* ... */ });
    it('should return null for invalid filename', () => { /* ... */ });
  });

  describe('saveHistorySnapshot', () => {
    it('should save snapshot to history directory', async () => { /* ... */ });
    it('should create history directory if missing', async () => { /* ... */ });
    it('should skip if maxHistory is 0', async () => { /* ... */ });
  });

  describe('listHistory', () => {
    it('should list all history entries sorted by date', async () => { /* ... */ });
    it('should return empty array for empty directory', async () => { /* ... */ });
    it('should skip non-JSON files', async () => { /* ... */ });
  });

  describe('pruneHistory', () => {
    it('should keep only maxHistory entries', async () => { /* ... */ });
    it('should delete oldest entries first', async () => { /* ... */ });
    it('should handle fewer entries than maxHistory', async () => { /* ... */ });
  });

  describe('getLatestSnapshot', () => {
    it('should return most recent snapshot', async () => { /* ... */ });
    it('should return null if no history', async () => { /* ... */ });
  });
});
```

```typescript
// tests/unit/utils/manifest.test.ts - ADD to existing file

describe('collectFileEntriesWithHashes', () => {
  it('should compute hashes for all files', async () => { /* ... */ });
  it('should skip files that no longer exist', async () => { /* ... */ });
  it('should handle permission errors gracefully', async () => { /* ... */ });
  it('should produce stable hashes for same content', async () => { /* ... */ });
});

describe('ManifestV2 Integration', () => {
  it('should round-trip V2 manifest correctly', async () => { /* ... */ });
  it('should detect modified files via hash comparison', async () => { /* ... */ });
});
```

### 6.2 Required Test Cases

```typescript
// Test: V2 manifest round-trip
it('should create and read V2 manifest with hashes', async () => {
  // Create test files
  await writeFile(path.join(testDir, 'test1.md'), 'content1');
  await writeFile(path.join(testDir, 'test2.md'), 'content2');
  
  // Collect hashes
  const entriesResult = await collectFileEntriesWithHashes(
    ['test1.md', 'test2.md'],
    testDir
  );
  expect(entriesResult.ok).toBe(true);
  
  const entries = entriesResult.value!;
  expect(entries).toHaveLength(2);
  expect(entries[0].hash).toMatch(/^sha256:[a-f0-9]{64}$/);
  
  // Create and write V2 manifest
  const manifest = createManifestV2(entries, [], '2.0.0');
  await writeManifest(testDir, manifest);
  
  // Read back
  const readResult = await readManifest(testDir);
  expect(readResult.ok).toBe(true);
  expect(isManifestV2(readResult.value!)).toBe(true);
  
  const readManifest = readResult.value as ManifestV2;
  expect(readManifest.files).toHaveLength(2);
  expect(readManifest.files[0].hash).toBe(entries[0].hash);
});

// Test: History snapshot
it('should save and retrieve history snapshot', async () => {
  const configDir = path.join(testDir, '.ai-tool-sync');
  const manifest: ManifestV2 = {
    version: '2.0.0',
    timestamp: new Date().toISOString(),
    files: [{ path: 'test.md', hash: 'sha256:abc123' }],
    directories: [],
  };
  
  // Save snapshot
  const saveResult = await saveHistorySnapshot(testDir, manifest, { configDir });
  expect(saveResult.ok).toBe(true);
  
  // Verify file exists
  const historyDir = path.join(configDir, 'history');
  const entries = await listHistory(historyDir);
  expect(entries.ok).toBe(true);
  expect(entries.value).toHaveLength(1);
  
  // Get latest
  const latestResult = await getLatestSnapshot(historyDir);
  expect(latestResult.ok).toBe(true);
  expect(latestResult.value?.version).toBe('2.0.0');
});
```

## 7. Integration Points

- **Imports from**:
  - `src/utils/fs.ts` - `fileExists`, `readFile`, `writeFile`, `ensureDir`, `deleteFile`, `readDir`
  - `src/utils/result.ts` - `Result`, `ok`, `err`, `tryCatchAsync`
  - `src/utils/logger.ts` - `logger` for debug/warn output
  - `src/utils/manifest.ts` - existing V2 types and `computeFileHash`

- **Exports to**:
  - `src/cli/commands/sync.ts` - uses `collectFileEntriesWithHashes`, `saveHistorySnapshot`
  - `src/cli/commands/clean.ts` - already uses V2 via `isFileModified`
  - `src/cli/commands/status.ts` - already uses V2 via `isFileModified`

- **Config**: No schema changes needed; uses existing `configDir` option

## 8. Acceptance Criteria

- [x] `ai-sync` generates V2 manifest with SHA256 hashes for all files
- [x] History snapshots saved to `.ai-tool-sync/history/<timestamp>.json`
- [x] History automatically pruned to 10 entries (configurable)
- [x] `ai-sync status` correctly identifies modified/unchanged/missing files
- [x] `ai-sync clean` skips user-modified files by default
- [x] All tests pass (`npm test -- manifest`)
- [x] No lint errors (`npm run lint`)
- [x] Types are strict (no `any`)
- [x] Functions exported from `src/utils/manifest.ts`
- [x] plan.md updated with T220 completion status

## 9. Out of Scope

- Migration from V1 to V2 manifest format (T221)
- Interactive prompts for cleanup (use `--force` flag)
- Per-target history (single unified history)
- Compression of history files (JSON is already compact)
- Cleanup of history files older than X days (use maxHistory count)

## 10. Implementation Checklist

1. [x] Create `src/utils/manifest-history.ts` with history management functions
2. [x] Add `collectFileEntriesWithHashes()` to `src/utils/manifest.ts`
3. [x] Export new functions from `src/utils/manifest.ts`
4. [x] Update `src/cli/commands/sync.ts`:
   - Change `MANIFEST_VERSION` to `'2.0.0'`
   - Replace `createManifest()` with `createManifestV2()` using hashes
   - Add `saveHistorySnapshot()` call after writing manifest
5. [x] Create `tests/unit/utils/manifest-history.test.ts`
6. [x] Extend `tests/unit/utils/manifest.test.ts` with V2 hash tests
7. [x] Run `npm test -- manifest`
8. [x] Run `npm run lint --fix`
9. [x] Run `npm run typecheck`
10. [x] Update plan.md with T220 completion status

## 11. API Reference

### `collectFileEntriesWithHashes(files, projectRoot)`

```typescript
/**
 * Collect file entries with computed SHA256 hashes
 * @param files - Array of relative file paths
 * @param projectRoot - Absolute path to project root
 * @returns Result containing array of ManifestFileEntry or error
 */
export async function collectFileEntriesWithHashes(
  files: string[],
  projectRoot: string
): Promise<Result<ManifestFileEntry[]>>;
```

### `saveHistorySnapshot(projectRoot, manifest, options?)`

```typescript
/**
 * Save manifest snapshot to history directory
 * @param projectRoot - Absolute path to project root
 * @param manifest - V2 manifest to save
 * @param options - History options (configDir, maxHistory)
 * @returns Result containing saved filename or error
 */
export async function saveHistorySnapshot(
  projectRoot: string,
  manifest: ManifestV2,
  options?: HistoryOptions
): Promise<Result<string>>;
```

### `listHistory(historyDir)`

```typescript
/**
 * List all history entries sorted by timestamp (newest first)
 * @param historyDir - Absolute path to history directory
 * @returns Result containing array of HistoryEntry or error
 */
export async function listHistory(
  historyDir: string
): Promise<Result<HistoryEntry[]>>;
```

### `getLatestSnapshot(historyDir)`

```typescript
/**
 * Get the most recent history snapshot
 * @param historyDir - Absolute path to history directory
 * @returns Result containing ManifestV2 or null if no history
 */
export async function getLatestSnapshot(
  historyDir: string
): Promise<Result<ManifestV2 | null>>;
```

### `pruneHistory(historyDir, maxHistory)`

```typescript
/**
 * Remove old history entries beyond maxHistory limit
 * @param historyDir - Absolute path to history directory
 * @param maxHistory - Maximum entries to keep
 * @returns Result containing array of deleted filenames
 */
export async function pruneHistory(
  historyDir: string,
  maxHistory: number
): Promise<Result<string[]>>;
```

