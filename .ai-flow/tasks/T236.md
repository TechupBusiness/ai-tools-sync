# T236: Implement Custom Variable Providers

> **Priority**: P2 | **Wave**: 9 | **Track**: E (Custom Variables)
> **Depends on**: T229 ✅ (Template Variable Substitution)
> **Estimated complexity**: Medium

## 1. Objective

Extend the template variable system (T229) to support user-defined variables in `config.yaml`. Users can define static string values or script-based providers that execute at sync time. This enables project-specific customization without modifying source code.

## 2. Syntax Design

### 2.1 Static Variables

Simple key-value pairs in config.yaml:

```yaml
# config.yaml
variables:
  company_name: "Acme Corp"
  team_email: "team@acme.com"
  docs_url: "https://docs.acme.com"
```

Usage in content:
```markdown
Contact {{team_email}} for support.
See {{docs_url}} for documentation.
```

### 2.2 Script-Based Variables

For dynamic values computed at sync time:

```yaml
# config.yaml
variables:
  # Simple command (stdout becomes value)
  build_hash:
    command: "git rev-parse HEAD"

  # Node script
  build_info:
    command: "node scripts/get-build-info.js"

  # With timeout override (default 5s)
  slow_operation:
    command: "python scripts/generate-metadata.py"
    timeout: 10000  # 10 seconds

  # With fallback on failure
  optional_version:
    command: "cat VERSION"
    fallback: "dev"

  # With cwd override
  submodule_version:
    command: "git describe --tags"
    cwd: "packages/core"
```

### 2.3 Priority Order

When the same variable is defined in multiple places:

1. **Custom variables from context** (highest - runtime override)
2. **Config variables** (`config.yaml variables:`)
3. **Built-in variables** (package.json, git, date)

## 3. Prior Art

Reference existing implementations:
- `src/transformers/template-variables.ts` - **Base to extend**: Add custom variable resolution
- `src/config/loader.ts` - **Config parsing**: Pattern for reading config.yaml
- `src/loaders/git.ts:779-789` - **execSync pattern**: Safe command execution
- `src/utils/result.ts` - **Error handling**: Result type pattern

## 4. File Structure

```
src/
├── transformers/
│   └── template-variables.ts    # Extend with custom variable support
├── config/
│   └── schema.ts                # Add variables schema
tests/
└── unit/
    └── transformers/
        └── template-variables.test.ts  # Add custom variable tests
```

## 5. Interfaces & Types

### 5.1 Config Schema Extension

```typescript
// In src/config/schema.ts or similar

/**
 * Custom variable definition in config.yaml
 */
export type CustomVariableValue = string | CustomVariableCommand;

export interface CustomVariableCommand {
  /** Shell command to execute (stdout becomes value) */
  command: string;
  /** Timeout in milliseconds (default: 5000) */
  timeout?: number;
  /** Fallback value if command fails */
  fallback?: string;
  /** Working directory for command (relative to project root) */
  cwd?: string;
}

/**
 * Variables section in config.yaml
 */
export interface ConfigVariables {
  [key: string]: CustomVariableValue;
}
```

### 5.2 Extended TemplateVariableContext

```typescript
// Update in src/transformers/template-variables.ts

export interface TemplateVariableContext {
  projectRoot?: string;
  config?: {
    project_name?: string;
    version?: string;
    /** User-defined variables from config.yaml */
    variables?: ConfigVariables;
    [key: string]: unknown;
  };
  /** Override or add custom variables (highest priority) */
  variables?: Record<string, string>;
}
```

## 6. Implementation Requirements

### 6.1 Command Execution Helper

```typescript
import { execSync } from 'node:child_process';

interface ExecuteCommandOptions {
  cwd: string;
  timeout: number;
  fallback?: string;
}

/**
 * Execute a command and return its stdout as a string
 * Returns fallback on failure, or undefined if no fallback
 */
function executeCommand(
  command: string,
  options: ExecuteCommandOptions
): string | undefined {
  try {
    const result = execSync(command, {
      cwd: options.cwd,
      encoding: 'utf-8',
      timeout: options.timeout,
      stdio: ['pipe', 'pipe', 'ignore'], // Suppress stderr
      // Security: Don't expand shell variables in command
      shell: true, // Needed for pipes, but command is user-controlled config
    });
    return result.trim() || undefined;
  } catch (error) {
    // Log warning but don't fail
    console.warn(`Variable command failed: ${command}`);
    return options.fallback;
  }
}
```

### 6.2 Resolve Custom Variables

```typescript
/**
 * Resolve custom variables from config.yaml
 * Called during resolveVariables() before built-in variables
 */
async function resolveCustomVariables(
  configVariables: ConfigVariables | undefined,
  projectRoot: string
): Promise<Record<string, string>> {
  if (!configVariables) {
    return {};
  }

  const resolved: Record<string, string> = {};
  const DEFAULT_TIMEOUT = 5000;

  for (const [key, value] of Object.entries(configVariables)) {
    // Validate key format (same as built-in: lowercase, underscores)
    if (!/^[a-z][a-z0-9_]*$/.test(key)) {
      console.warn(`Invalid variable name "${key}" - must be lowercase with underscores`);
      continue;
    }

    if (typeof value === 'string') {
      // Static value
      resolved[key] = value;
    } else if (typeof value === 'object' && value.command) {
      // Command-based value
      const cwd = value.cwd
        ? path.resolve(projectRoot, value.cwd)
        : projectRoot;

      const result = executeCommand(value.command, {
        cwd,
        timeout: value.timeout ?? DEFAULT_TIMEOUT,
        fallback: value.fallback,
      });

      if (result !== undefined) {
        resolved[key] = result;
      }
    }
  }

  return resolved;
}
```

### 6.3 Integration in resolveVariables()

```typescript
async function resolveVariables(context: TemplateVariableContext): Promise<ResolvedVariables> {
  const variables: ResolvedVariables = {};
  const projectRoot = context.projectRoot ?? process.cwd();

  // 1. Custom variables from context (highest priority - runtime override)
  if (context.variables) {
    Object.assign(variables, context.variables);
  }

  // 2. Config variables from config.yaml (NEW)
  if (context.config?.variables) {
    const customVars = await resolveCustomVariables(
      context.config.variables,
      projectRoot
    );
    for (const [key, value] of Object.entries(customVars)) {
      variables[key] ??= value; // Don't override context.variables
    }
  }

  // 3. Config values (project_name, version)
  if (context.config?.project_name) {
    variables.project_name ??= context.config.project_name;
  }
  // ... rest of existing implementation
}
```

## 7. Security Considerations

### 7.1 Command Execution Safety

- Commands are defined in `config.yaml` which is under user control
- This is similar to npm scripts or git hooks - user-defined project configuration
- Commands run with the same permissions as the sync process
- **NOT** arbitrary user input - only config file values

### 7.2 Restrictions

```typescript
// Enforced restrictions:
// 1. Commands only execute from project root or subdirectories
if (!resolvedCwd.startsWith(projectRoot)) {
  console.warn(`Variable cwd must be within project: ${value.cwd}`);
  continue;
}

// 2. Timeout enforced (default 5s, max 30s)
const timeout = Math.min(value.timeout ?? 5000, 30000);

// 3. stderr is suppressed (no output pollution)
// 4. Exit code != 0 treated as failure (uses fallback)
```

### 7.3 What We Don't Do

- No remote command execution
- No network fetching in variable resolution (use T230 for that)
- No recursive variable expansion ({{var}} in command output)
- No shell variable expansion in values

## 8. Test Requirements

### 8.1 Test Cases

```typescript
describe('custom variables', () => {
  describe('static variables', () => {
    it('should resolve static string variables', async () => {
      const content = 'Company: {{company_name}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            company_name: 'Acme Corp',
          },
        },
      });
      expect(result).toBe('Company: Acme Corp');
    });

    it('should allow context.variables to override config variables', async () => {
      const content = '{{name}}';
      const result = await transformTemplateVariables(content, {
        variables: { name: 'Override' },
        config: {
          variables: { name: 'Config' },
        },
      });
      expect(result).toBe('Override');
    });
  });

  describe('command variables', () => {
    it('should execute simple command', async () => {
      const content = '{{echo_test}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            echo_test: { command: 'echo hello' },
          },
        },
      });
      expect(result).toBe('hello');
    });

    it('should use fallback on command failure', async () => {
      const content = '{{missing}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            missing: {
              command: 'cat /nonexistent/file',
              fallback: 'default',
            },
          },
        },
      });
      expect(result).toBe('default');
    });

    it('should timeout long-running commands', async () => {
      const content = '{{slow}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            slow: {
              command: 'sleep 10',
              timeout: 100,
              fallback: 'timed out',
            },
          },
        },
      });
      expect(result).toBe('timed out');
    });

    it('should respect cwd option', async () => {
      // Create temp directory structure for test
      const content = '{{subdir_file}}';
      const result = await transformTemplateVariables(content, {
        projectRoot: '/tmp/test-project',
        config: {
          variables: {
            subdir_file: {
              command: 'cat VERSION',
              cwd: 'packages/core',
            },
          },
        },
      });
      // Assert based on fixture
    });
  });

  describe('variable name validation', () => {
    it('should reject uppercase variable names', async () => {
      const content = '{{UPPER}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            UPPER: 'should not work',
          },
        },
      });
      // Variable not resolved, preserved
      expect(result).toBe('{{UPPER}}');
    });

    it('should reject names starting with numbers', async () => {
      const content = '{{123var}}';
      const result = await transformTemplateVariables(content, {
        config: {
          variables: {
            '123var': 'should not work',
          },
        },
      });
      expect(result).toBe('{{123var}}');
    });
  });
});
```

## 9. Config Schema Update

Add to JSON schema for config.yaml validation:

```json
{
  "properties": {
    "variables": {
      "type": "object",
      "description": "Custom template variables",
      "additionalProperties": {
        "oneOf": [
          { "type": "string" },
          {
            "type": "object",
            "properties": {
              "command": { "type": "string" },
              "timeout": { "type": "number", "minimum": 100, "maximum": 30000 },
              "fallback": { "type": "string" },
              "cwd": { "type": "string" }
            },
            "required": ["command"],
            "additionalProperties": false
          }
        ]
      }
    }
  }
}
```

## 10. Acceptance Criteria

- [ ] Static variables in config.yaml resolve correctly
- [ ] Command-based variables execute and capture stdout
- [ ] Timeout enforced on command execution
- [ ] Fallback values used when commands fail
- [ ] cwd option works for subdirectory commands
- [ ] Variable name validation (lowercase, underscores)
- [ ] Context variables override config variables
- [ ] Config variables override built-in variables
- [ ] Security: cwd restricted to project root
- [ ] All tests pass
- [ ] No lint errors
- [ ] Config schema updated
- [ ] plan.md updated with completion status

## 11. Out of Scope

- Remote/network variable sources (use T230)
- Recursive variable expansion
- Async/parallel command execution
- Variable caching across syncs (only per-sync caching)
- GUI/interactive variable prompts
- Encrypted/secret variables

## 12. Example Usage

### config.yaml

```yaml
project_name: "My Awesome Project"

variables:
  # Static values
  company: "Acme Corp"
  support_email: "support@acme.com"

  # Git-based
  release_tag:
    command: "git describe --tags --always"
    fallback: "dev"

  # From file
  changelog_version:
    command: "head -1 CHANGELOG.md | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+'"
    fallback: "unreleased"

  # From script
  build_metadata:
    command: "node scripts/build-metadata.js"
    timeout: 10000

  # Submodule info
  core_version:
    command: "cat package.json | jq -r .version"
    cwd: "packages/core"
```

### Content using variables

```markdown
# {{project_name}}

Version: {{version}} ({{release_tag}})
Built by: {{company}}

For support, contact {{support_email}}.

## Core Package

Version: {{core_version}}
```

### Output

```markdown
# My Awesome Project

Version: 1.0.0 (v1.0.0-beta.3)
Built by: Acme Corp

For support, contact support@acme.com.

## Core Package

Version: 2.3.1
```
